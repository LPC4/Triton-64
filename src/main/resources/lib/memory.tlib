; ==================================================================================
; DYNAMIC MEMORY ALLOCATOR MODULE
; ==================================================================================
;
; This module provides a complete dynamic memory management system with malloc(),
; free(), realloc(), and calloc() functions. It manages a heap using a simple
; free list with first-fit allocation strategy.
;
; MEMORY LAYOUT:
; The heap starts at address 402784256 (384MB) with 134217728 bytes (128MB) total.
; Each allocated block has an 8-byte header containing size and metadata.
;
; BLOCK STRUCTURE:
; Each memory block has an 8-byte header followed by the data area
;
; FREE BLOCK:
; +------------------+------------------+
; | SIZE (32-bit)    | NEXT PTR (32-bit)| <- Header (8 bytes)
; +------------------+------------------+
; |        DATA AREA (SIZE-8 bytes)     | <- Available for allocation
; +--------------------------------------+
;
; ALLOCATED BLOCK:
; +------------------+------------------+
; | SIZE (32-bit)    |    0 (32-bit)    | <- Header (8 bytes)
; +------------------+------------------+
; |        DATA AREA (SIZE-8 bytes)     | <- User data
; +--------------------------------------+
;
; HEADER ENCODING:
; Header = (SIZE << 32) | NEXT_PTR
; - SIZE: Total block size including header (upper 32 bits)
; - NEXT_PTR: Address of next free block, 0 if allocated (lower 32 bits)
; - User receives pointer to data area (header address + 8)
;
; FREE LIST MANAGEMENT:
; - Single linked list of free blocks maintained in memory
; - freeListHead points to first free block
; - Each free block header contains pointer to next free block
; - Allocated blocks have NEXT_PTR = 0 (marks them as in-use)
; - Coalescing merges adjacent free blocks to reduce fragmentation
;
; ALLOCATION STRATEGY:
; - First-fit: Uses first free block large enough for request
; - Block splitting: Large blocks split to avoid waste
; - Alignment: All allocations aligned to 8-byte boundaries
; - Minimum block size: 16 bytes (8 header + 8 data)
;
; FUNCTIONS PROVIDED:
; - malloc(size): Allocate size bytes, returns pointer or 0 on failure
; - free(ptr): Free previously allocated memory block
; - realloc(ptr, size): Resize allocated block, preserving data
; - calloc(count, size): Allocate zero-initialized array
; - get_heap_stats(): Get memory usage statistics
;
; SAFETY FEATURES:
; - Input validation on all functions
; - Pointer bounds checking
; - Double-free protection
; - Heap corruption detection
; - Automatic coalescing of adjacent free blocks

global freeListHead = 0

; Constants
global HEAP_START = 402784256
global HEAP_SIZE = 134217728
global HEADER_SIZE = 8
global MIN_BLOCK_SIZE = 16
global ALIGNMENT = 8

func write64(addr, value) {
    @addr = value
}

func read64(addr) {
    return @addr
}

func align_up(size, alignment) {
    return (size + alignment - 1) & ~(alignment - 1)
}

func get_block_size(header_addr) {
    return read64(header_addr) >> 32
}

func get_next_block(header_addr) {
    return read64(header_addr) & ((1 << 32) - 1)
}

func set_header(header_addr, size, next) {
    write64(header_addr, (size << 32) | next)
}

func init_heap() {
    if (freeListHead == 0) {
        freeListHead = HEAP_START
        set_header(freeListHead, HEAP_SIZE, 0)
    }
}

func unlink_block(block, prev) {
    var next = get_next_block(block)

    if (prev == 0) {
        freeListHead = next
    } else {
        var prev_size = get_block_size(prev)
        set_header(prev, prev_size, next)
    }
}

func split_block(block, needed_size) {
    var total_size = get_block_size(block)
    var remaining = total_size - needed_size

    if (remaining >= MIN_BLOCK_SIZE) {
        var new_block = block + needed_size
        set_header(new_block, remaining, freeListHead)
        freeListHead = new_block
        set_header(block, needed_size, 0)
    } else {
        set_header(block, total_size, 0)
    }
}

func malloc(size_req) {
    if (size_req == 0) {
        return 0
    }

    init_heap()

    var aligned_size = align_up(size_req, ALIGNMENT)
    var total_needed = aligned_size + HEADER_SIZE

    var current = freeListHead
    var prev = 0

    while (current != 0) {
        var block_size = get_block_size(current)
        var next_block = get_next_block(current)

        if (block_size >= total_needed) {
            unlink_block(current, prev)
            split_block(current, total_needed)
            return current + HEADER_SIZE
        }

        prev = current
        current = next_block
    }

    return 0
}

func is_valid_ptr(ptr) {
    if (ptr == 0) {
        return 0
    }

    var header_addr = ptr - HEADER_SIZE

    if (header_addr < HEAP_START || header_addr >= HEAP_START + HEAP_SIZE) {
        return 0
    }

    var size = get_block_size(header_addr)
    if (size < MIN_BLOCK_SIZE || size > HEAP_SIZE) {
        return 0
    }

    var next = get_next_block(header_addr)
    if (next != 0) {
        return 0
    }

    return 1
}

func coalesce_free_blocks() {
    if (freeListHead == 0) {
        return
    }

    var current = freeListHead

    while (current != 0) {
        var current_size = get_block_size(current)
        var next = get_next_block(current)

        if (next != 0 && next == current + current_size) {
            var next_size = get_block_size(next)
            var next_next = get_next_block(next)

            set_header(current, current_size + next_size, next_next)
        } else {
            current = next
        }
    }
}

func free(ptr) {
    if (~is_valid_ptr(ptr) & 1) {
        return
    }

    var header_addr = ptr - HEADER_SIZE
    var block_size = get_block_size(header_addr)

    set_header(header_addr, block_size, freeListHead)
    freeListHead = header_addr

    coalesce_free_blocks()
}

func realloc(ptr, new_size) {
    if (ptr == 0) {
        return malloc(new_size)
    }

    if (new_size == 0) {
        free(ptr)
        return 0
    }

    if (~is_valid_ptr(ptr) & 1) {
        return 0
    }

    var header_addr = ptr - HEADER_SIZE
    var current_size = get_block_size(header_addr) - HEADER_SIZE
    var aligned_new_size = align_up(new_size, ALIGNMENT)

    if (aligned_new_size <= current_size) {
        return ptr
    }

    var new_ptr = malloc(new_size)
    if (new_ptr == 0) {
        return 0
    }

    var copy_size = current_size
    if (aligned_new_size < copy_size) {
        copy_size = aligned_new_size
    }

    var i = 0
    while (i < copy_size) {
        @(new_ptr + i) = @(ptr + i)
        i = i + 1
    }

    free(ptr)
    return new_ptr
}

func calloc(count, size) {
    var total_size = count * size
    var ptr = malloc(total_size)

    if (ptr == 0) {
        return 0
    }

    var i = 0
    while (i < total_size) {
        @(ptr + i) = 0
        i = i + 1
    }

    return ptr
}

func get_heap_stats(total_free, total_allocated, free_blocks) {
    @total_free = 0
    @total_allocated = 0
    @free_blocks = 0

    var current = freeListHead

    while (current != 0) {
        @total_free = @total_free + get_block_size(current)
        @free_blocks = @free_blocks + 1
        current = get_next_block(current)
    }

    @total_allocated = HEAP_SIZE - @total_free
}