    ; Program entry point
_start:

    ; ====================================
    ; Global variables
    ; ====================================
    ADD hp, gp, 48
    ; Allocated 48 bytes for global variables
    ; Total global data size: 48 bytes
    ; Literal value: 402784256
    LDI t0, 402784256
    LDI t1, 0
    ADD t1, gp, t1
    ST t1, t0
    ; Literal value: 134217728
    LDI t0, 134217728
    LDI t1, 8
    ADD t1, gp, t1
    ST t1, t0
    ; Literal value: 8
    LDI t0, 8
    LDI t1, 16
    ADD t1, gp, t1
    ST t1, t0
    ; Literal value: 16
    LDI t0, 16
    LDI t1, 24
    ADD t1, gp, t1
    ST t1, t0
    ; Literal value: 8
    LDI t0, 8
    LDI t1, 32
    ADD t1, gp, t1
    ST t1, t0
    ; Literal value: 0
    LDI t0, 0
    LDI t1, 40
    ADD t1, gp, t1
    ST t1, t0
    JAL main, ra
    HLT

    ; ===================================
    ; Function: write64
    ; ===================================
write64:
    ; Pre-allocating 0 local variables
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 0 bytes
    ; Variable access: addr
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    ; Dereference assignment to address: t1
    ; Variable access: value
    LDI t0, 24
    ADD t0, fp, t0
    LD t2, t0
    ; Store LONG to address t1
    ST t1, t2
    ; Function epilogue
write64_end_0:
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ====================================
    ; Function: read64
    ; ====================================
read64:
    ; Pre-allocating 0 local variables
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 0 bytes
    ; Return statement
    ; Dereference operation
    ; Variable access: addr
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    LD t0, t2
    MOV a0, t0
    JMP read64_end_1
    ; Function epilogue
read64_end_1:
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ==================================
    ; Function: align_up
    ; ==================================
align_up:
    ; Pre-allocating 0 local variables
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 0 bytes
    ; Return statement
    ; Arithmetic operation: AND
    ; Arithmetic operation: SUB
    ; Arithmetic operation: ADD
    ; Variable access: size
    LDI t3, 16
    ADD t3, fp, t3
    LD t4, t3
    ; Variable access: alignment
    LDI t3, 24
    ADD t3, fp, t3
    LD t5, t3
    ADD t2, t4, t5
    ; Literal value: 1
    LDI t3, 1
    SUB t1, t2, t3
    ; Unary operation: NOT
    ; Arithmetic operation: SUB
    ; Variable access: alignment
    LDI t3, 24
    ADD t3, fp, t3
    LD t4, t3
    ; Literal value: 1
    LDI t3, 1
    SUB t2, t4, t3
    NOT t3, t2
    AND t0, t1, t3
    MOV a0, t0
    JMP align_up_end_2
    ; Function epilogue
align_up_end_2:
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ============================
    ; Function: get_block_size
    ; ============================
get_block_size:
    ; Pre-allocating 0 local variables
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 0 bytes
    ; Return statement
    ; Arithmetic operation: SHR
    ; Function call: read64
    ; Preparing function call: read64
    ; Saving 1 live temporaries
    PUSH t0
    ; Evaluating argument 0
    ; Variable access: header_addr
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    PUSH t2
    JAL read64, ra
    LDI t1, 8
    ADD sp, sp, t1
    ; Cleaned up 1 arguments from stack
    MOV t1, a0
    ; Restoring 1 saved temporaries
    POP t0
    ; Literal value: 32
    LDI t2, 32
    SHR t0, t1, t2
    MOV a0, t0
    JMP get_block_size_end_3
    ; Function epilogue
get_block_size_end_3:
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ============================
    ; Function: get_next_block
    ; ============================
get_next_block:
    ; Pre-allocating 0 local variables
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 0 bytes
    ; Return statement
    ; Arithmetic operation: AND
    ; Function call: read64
    ; Preparing function call: read64
    ; Saving 1 live temporaries
    PUSH t0
    ; Evaluating argument 0
    ; Variable access: header_addr
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    PUSH t2
    JAL read64, ra
    LDI t1, 8
    ADD sp, sp, t1
    ; Cleaned up 1 arguments from stack
    MOV t1, a0
    ; Restoring 1 saved temporaries
    POP t0
    ; Arithmetic operation: SUB
    ; Arithmetic operation: SHL
    ; Literal value: 1
    LDI t4, 1
    ; Literal value: 32
    LDI t5, 32
    SHL t3, t4, t5
    ; Literal value: 1
    LDI t4, 1
    SUB t2, t3, t4
    AND t0, t1, t2
    MOV a0, t0
    JMP get_next_block_end_4
    ; Function epilogue
get_next_block_end_4:
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ================================
    ; Function: set_header
    ; ================================
set_header:
    ; Pre-allocating 0 local variables
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 0 bytes
    ; Expression statement
    ; Function call: write64
    ; Preparing function call: write64
    ; Evaluating argument 0
    ; Variable access: header_addr
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Arithmetic operation: OR
    ; Arithmetic operation: SHL
    ; Variable access: size
    LDI t3, 24
    ADD t3, fp, t3
    LD t4, t3
    ; Literal value: 32
    LDI t3, 32
    SHL t2, t4, t3
    ; Variable access: next
    LDI t3, 32
    ADD t3, fp, t3
    LD t4, t3
    OR t0, t2, t4
    PUSH t0
    PUSH t1
    JAL write64, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    ; Function epilogue
set_header_end_5:
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; =================================
    ; Function: init_heap
    ; =================================
init_heap:
    ; Pre-allocating 0 local variables
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 0 bytes
    ; If statement
    ; Comparison: Variable(name=freeListHead, type=LONG) EQ Literal(value=0, type=LONG)
    ; Variable access: freeListHead
    LDI t0, 40
    ADD t0, gp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_7, t2
    ; Variable assignment: freeListHead
    ; Variable access: HEAP_START
    LDI t0, 0
    ADD t0, gp, t0
    LD t1, t0
    LDI t0, 40
    ADD t0, gp, t0
    ST t0, t1
    ; Expression statement
    ; Function call: set_header
    ; Preparing function call: set_header
    ; Evaluating argument 0
    ; Variable access: freeListHead
    LDI t0, 40
    ADD t0, gp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: HEAP_SIZE
    LDI t0, 8
    ADD t0, gp, t0
    LD t2, t0
    ; Evaluating argument 2
    ; Literal value: 0
    LDI t0, 0
    PUSH t0
    PUSH t2
    PUSH t1
    JAL set_header, ra
    LDI t0, 24
    ADD sp, sp, t0
    ; Cleaned up 3 arguments from stack
    MOV t0, a0
else_7:
    ; Function epilogue
init_heap_end_6:
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ==============================
    ; Function: unlink_block
    ; ==============================
unlink_block:
    ; Pre-allocating 2 local variables
    ; Pre-allocated variable: next (LONG)
    ; Pre-allocated variable: prev_size (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 16 bytes
    LDI t0, 16
    SUB sp, sp, t0
    ; Allocated 16 bytes for stack frame
    ; Variable declaration: next
    ; Function call: get_next_block
    ; Preparing function call: get_next_block
    ; Evaluating argument 0
    ; Variable access: block
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL get_next_block, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; If statement
    ; Comparison: Variable(name=prev, type=LONG) EQ Literal(value=0, type=LONG)
    ; Variable access: prev
    LDI t0, 24
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_10, t2
    ; Variable assignment: freeListHead
    ; Variable access: next
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 40
    ADD t0, gp, t0
    ST t0, t1
    JMP endif_11
else_10:
    ; Variable declaration: prev_size
    ; Function call: get_block_size
    ; Preparing function call: get_block_size
    ; Evaluating argument 0
    ; Variable access: prev
    LDI t0, 24
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL get_block_size, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; Expression statement
    ; Function call: set_header
    ; Preparing function call: set_header
    ; Evaluating argument 0
    ; Variable access: prev
    LDI t0, 24
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: prev_size
    LDI t0, -16
    ADD t0, fp, t0
    LD t2, t0
    ; Evaluating argument 2
    ; Variable access: next
    LDI t0, -8
    ADD t0, fp, t0
    LD t3, t0
    PUSH t3
    PUSH t2
    PUSH t1
    JAL set_header, ra
    LDI t0, 24
    ADD sp, sp, t0
    ; Cleaned up 3 arguments from stack
    MOV t0, a0
endif_11:
    ; Function epilogue
unlink_block_end_9:
    LDI t0, 16
    ADD sp, sp, t0
    ; Deallocated 16 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ===============================
    ; Function: split_block
    ; ===============================
split_block:
    ; Pre-allocating 3 local variables
    ; Pre-allocated variable: total_size (LONG)
    ; Pre-allocated variable: remaining (LONG)
    ; Pre-allocated variable: new_block (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 24 bytes
    LDI t0, 24
    SUB sp, sp, t0
    ; Allocated 24 bytes for stack frame
    ; Variable declaration: total_size
    ; Function call: get_block_size
    ; Preparing function call: get_block_size
    ; Evaluating argument 0
    ; Variable access: block
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL get_block_size, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: remaining
    ; Arithmetic operation: SUB
    ; Variable access: total_size
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: needed_size
    LDI t1, 24
    ADD t1, fp, t1
    LD t3, t1
    SUB t0, t2, t3
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; If statement
    ; Comparison: Variable(name=remaining, type=LONG) GE Variable(name=MIN_BLOCK_SIZE, type=LONG)
    ; Variable access: remaining
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    ; Variable access: MIN_BLOCK_SIZE
    LDI t0, 24
    ADD t0, gp, t0
    LD t2, t0
    SUB t0, t1, t2
    ; Jump if t1 < t2
    JPN else_13, t0
    ; Variable declaration: new_block
    ; Arithmetic operation: ADD
    ; Variable access: block
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: needed_size
    LDI t1, 24
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    ; Expression statement
    ; Function call: set_header
    ; Preparing function call: set_header
    ; Evaluating argument 0
    ; Variable access: new_block
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: remaining
    LDI t0, -16
    ADD t0, fp, t0
    LD t2, t0
    ; Evaluating argument 2
    ; Variable access: freeListHead
    LDI t0, 40
    ADD t0, gp, t0
    LD t3, t0
    PUSH t3
    PUSH t2
    PUSH t1
    JAL set_header, ra
    LDI t0, 24
    ADD sp, sp, t0
    ; Cleaned up 3 arguments from stack
    MOV t0, a0
    ; Variable assignment: freeListHead
    ; Variable access: new_block
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 40
    ADD t0, gp, t0
    ST t0, t1
    ; Expression statement
    ; Function call: set_header
    ; Preparing function call: set_header
    ; Evaluating argument 0
    ; Variable access: block
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: needed_size
    LDI t0, 24
    ADD t0, fp, t0
    LD t2, t0
    ; Evaluating argument 2
    ; Literal value: 0
    LDI t0, 0
    PUSH t0
    PUSH t2
    PUSH t1
    JAL set_header, ra
    LDI t0, 24
    ADD sp, sp, t0
    ; Cleaned up 3 arguments from stack
    MOV t0, a0
    JMP endif_14
else_13:
    ; Expression statement
    ; Function call: set_header
    ; Preparing function call: set_header
    ; Evaluating argument 0
    ; Variable access: block
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: total_size
    LDI t0, -8
    ADD t0, fp, t0
    LD t2, t0
    ; Evaluating argument 2
    ; Literal value: 0
    LDI t0, 0
    PUSH t0
    PUSH t2
    PUSH t1
    JAL set_header, ra
    LDI t0, 24
    ADD sp, sp, t0
    ; Cleaned up 3 arguments from stack
    MOV t0, a0
endif_14:
    ; Function epilogue
split_block_end_12:
    LDI t0, 24
    ADD sp, sp, t0
    ; Deallocated 24 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ====================================
    ; Function: malloc
    ; ====================================
malloc:
    ; Pre-allocating 6 local variables
    ; Pre-allocated variable: aligned_size (LONG)
    ; Pre-allocated variable: total_needed (LONG)
    ; Pre-allocated variable: current (LONG)
    ; Pre-allocated variable: prev (LONG)
    ; Pre-allocated variable: block_size (LONG)
    ; Pre-allocated variable: next_block (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 48 bytes
    LDI t0, 48
    SUB sp, sp, t0
    ; Allocated 48 bytes for stack frame
    ; If statement
    ; Comparison: Variable(name=size_req, type=LONG) EQ Literal(value=0, type=LONG)
    ; Variable access: size_req
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_16, t2
    ; Return statement
    ; Literal value: 0
    LDI t0, 0
    MOV a0, t0
    JMP malloc_end_15
else_16:
    ; Expression statement
    ; Function call: init_heap
    ; Preparing function call: init_heap
    JAL init_heap, ra
    MOV t0, a0
    ; Variable declaration: aligned_size
    ; Function call: align_up
    ; Preparing function call: align_up
    ; Evaluating argument 0
    ; Variable access: size_req
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: ALIGNMENT
    LDI t0, 32
    ADD t0, gp, t0
    LD t2, t0
    PUSH t2
    PUSH t1
    JAL align_up, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: total_needed
    ; Arithmetic operation: ADD
    ; Variable access: aligned_size
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: HEADER_SIZE
    LDI t1, 16
    ADD t1, gp, t1
    LD t3, t1
    ADD t0, t2, t3
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: current
    ; Variable access: freeListHead
    LDI t0, 40
    ADD t0, gp, t0
    LD t1, t0
    LDI t0, -24
    ADD t0, fp, t0
    ST t0, t1
    ; Variable declaration: prev
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -32
    ADD t1, fp, t1
    ST t1, t0
    ; While loop
loop_18:
    ; Comparison: Variable(name=current, type=LONG) NE Literal(value=0, type=LONG)
    ; Variable access: current
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 == t0
    JZ endloop_19, t2
    ; Variable declaration: block_size
    ; Function call: get_block_size
    ; Preparing function call: get_block_size
    ; Evaluating argument 0
    ; Variable access: current
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL get_block_size, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -40
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: next_block
    ; Function call: get_next_block
    ; Preparing function call: get_next_block
    ; Evaluating argument 0
    ; Variable access: current
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL get_next_block, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -48
    ADD t1, fp, t1
    ST t1, t0
    ; If statement
    ; Comparison: Variable(name=block_size, type=LONG) GE Variable(name=total_needed, type=LONG)
    ; Variable access: block_size
    LDI t0, -40
    ADD t0, fp, t0
    LD t1, t0
    ; Variable access: total_needed
    LDI t0, -16
    ADD t0, fp, t0
    LD t2, t0
    SUB t0, t1, t2
    ; Jump if t1 < t2
    JPN else_20, t0
    ; Expression statement
    ; Function call: unlink_block
    ; Preparing function call: unlink_block
    ; Evaluating argument 0
    ; Variable access: current
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: prev
    LDI t0, -32
    ADD t0, fp, t0
    LD t2, t0
    PUSH t2
    PUSH t1
    JAL unlink_block, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: split_block
    ; Preparing function call: split_block
    ; Evaluating argument 0
    ; Variable access: current
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: total_needed
    LDI t0, -16
    ADD t0, fp, t0
    LD t2, t0
    PUSH t2
    PUSH t1
    JAL split_block, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    ; Return statement
    ; Arithmetic operation: ADD
    ; Variable access: current
    LDI t1, -24
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: HEADER_SIZE
    LDI t1, 16
    ADD t1, gp, t1
    LD t3, t1
    ADD t0, t2, t3
    MOV a0, t0
    JMP malloc_end_15
else_20:
    ; Variable assignment: prev
    ; Variable access: current
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, -32
    ADD t0, fp, t0
    ST t0, t1
    ; Variable assignment: current
    ; Variable access: next_block
    LDI t0, -48
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, -24
    ADD t0, fp, t0
    ST t0, t1
    JMP loop_18
endloop_19:
    ; Return statement
    ; Literal value: 0
    LDI t0, 0
    MOV a0, t0
    JMP malloc_end_15
    ; Function epilogue
malloc_end_15:
    LDI t0, 48
    ADD sp, sp, t0
    ; Deallocated 48 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ==============================
    ; Function: is_valid_ptr
    ; ==============================
is_valid_ptr:
    ; Pre-allocating 3 local variables
    ; Pre-allocated variable: header_addr (LONG)
    ; Pre-allocated variable: size (LONG)
    ; Pre-allocated variable: next (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 24 bytes
    LDI t0, 24
    SUB sp, sp, t0
    ; Allocated 24 bytes for stack frame
    ; If statement
    ; Comparison: Variable(name=ptr, type=LONG) EQ Literal(value=0, type=LONG)
    ; Variable access: ptr
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_23, t2
    ; Return statement
    ; Literal value: 0
    LDI t0, 0
    MOV a0, t0
    JMP is_valid_ptr_end_22
else_23:
    ; Variable declaration: header_addr
    ; Arithmetic operation: SUB
    ; Variable access: ptr
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: HEADER_SIZE
    LDI t1, 16
    ADD t1, gp, t1
    LD t3, t1
    SUB t0, t2, t3
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; If statement
    ; Logical OR: BinaryOp(op=LT, left=Variable(name=header_addr, type=LONG), right=Variable(name=HEAP_START, type=LONG)) || BinaryOp(op=GE, left=Variable(name=header_addr, type=LONG), right=BinaryOp(op=ADD, left=Variable(name=HEAP_START, type=LONG), right=Variable(name=HEAP_SIZE, type=LONG)))
    ; Comparison: Variable(name=header_addr, type=LONG) LT Variable(name=HEAP_START, type=LONG)
    ; Variable access: header_addr
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    ; Variable access: HEAP_START
    LDI t0, 0
    ADD t0, gp, t0
    LD t2, t0
    SUB t0, t1, t2
    ; Jump if t1 >= t2
    JPN skip_ge_28, t0
    JMP or_eval_right_27
skip_ge_28:
    JMP or_skip_29
or_eval_right_27:
    ; Comparison: Variable(name=header_addr, type=LONG) GE BinaryOp(op=ADD, left=Variable(name=HEAP_START, type=LONG), right=Variable(name=HEAP_SIZE, type=LONG))
    ; Variable access: header_addr
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    ; Arithmetic operation: ADD
    ; Variable access: HEAP_START
    LDI t2, 0
    ADD t2, gp, t2
    LD t3, t2
    ; Variable access: HEAP_SIZE
    LDI t2, 8
    ADD t2, gp, t2
    LD t4, t2
    ADD t0, t3, t4
    SUB t2, t1, t0
    ; Jump if t1 < t0
    JPN else_25, t2
or_skip_29:
    ; Return statement
    ; Literal value: 0
    LDI t0, 0
    MOV a0, t0
    JMP is_valid_ptr_end_22
else_25:
    ; Variable declaration: size
    ; Function call: get_block_size
    ; Preparing function call: get_block_size
    ; Evaluating argument 0
    ; Variable access: header_addr
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL get_block_size, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; If statement
    ; Logical OR: BinaryOp(op=LT, left=Variable(name=size, type=LONG), right=Variable(name=MIN_BLOCK_SIZE, type=LONG)) || BinaryOp(op=GT, left=Variable(name=size, type=LONG), right=Variable(name=HEAP_SIZE, type=LONG))
    ; Comparison: Variable(name=size, type=LONG) LT Variable(name=MIN_BLOCK_SIZE, type=LONG)
    ; Variable access: size
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    ; Variable access: MIN_BLOCK_SIZE
    LDI t0, 24
    ADD t0, gp, t0
    LD t2, t0
    SUB t0, t1, t2
    ; Jump if t1 >= t2
    JPN skip_ge_33, t0
    JMP or_eval_right_32
skip_ge_33:
    JMP or_skip_34
or_eval_right_32:
    ; Comparison: Variable(name=size, type=LONG) GT Variable(name=HEAP_SIZE, type=LONG)
    ; Variable access: size
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    ; Variable access: HEAP_SIZE
    LDI t0, 8
    ADD t0, gp, t0
    LD t2, t0
    SUB t0, t1, t2
    ; Jump if t1 <= t2
    JPP skip_le_35, t0
    JMP else_30
skip_le_35:
or_skip_34:
    ; Return statement
    ; Literal value: 0
    LDI t0, 0
    MOV a0, t0
    JMP is_valid_ptr_end_22
else_30:
    ; Variable declaration: next
    ; Function call: get_next_block
    ; Preparing function call: get_next_block
    ; Evaluating argument 0
    ; Variable access: header_addr
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL get_next_block, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    ; If statement
    ; Comparison: Variable(name=next, type=LONG) NE Literal(value=0, type=LONG)
    ; Variable access: next
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 == t0
    JZ else_36, t2
    ; Return statement
    ; Literal value: 0
    LDI t0, 0
    MOV a0, t0
    JMP is_valid_ptr_end_22
else_36:
    ; Return statement
    ; Literal value: 1
    LDI t0, 1
    MOV a0, t0
    JMP is_valid_ptr_end_22
    ; Function epilogue
is_valid_ptr_end_22:
    LDI t0, 24
    ADD sp, sp, t0
    ; Deallocated 24 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ======================
    ; Function: coalesce_free_blocks
    ; ======================
coalesce_free_blocks:
    ; Pre-allocating 5 local variables
    ; Pre-allocated variable: current (LONG)
    ; Pre-allocated variable: current_size (LONG)
    ; Pre-allocated variable: next (LONG)
    ; Pre-allocated variable: next_size (LONG)
    ; Pre-allocated variable: next_next (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 40 bytes
    LDI t0, 40
    SUB sp, sp, t0
    ; Allocated 40 bytes for stack frame
    ; If statement
    ; Comparison: Variable(name=freeListHead, type=LONG) EQ Literal(value=0, type=LONG)
    ; Variable access: freeListHead
    LDI t0, 40
    ADD t0, gp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_39, t2
    ; Return statement
    JMP coalesce_free_blocks_end_38
else_39:
    ; Variable declaration: current
    ; Variable access: freeListHead
    LDI t0, 40
    ADD t0, gp, t0
    LD t1, t0
    LDI t0, -8
    ADD t0, fp, t0
    ST t0, t1
    ; While loop
loop_41:
    ; Comparison: Variable(name=current, type=LONG) NE Literal(value=0, type=LONG)
    ; Variable access: current
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 == t0
    JZ endloop_42, t2
    ; Variable declaration: current_size
    ; Function call: get_block_size
    ; Preparing function call: get_block_size
    ; Evaluating argument 0
    ; Variable access: current
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL get_block_size, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: next
    ; Function call: get_next_block
    ; Preparing function call: get_next_block
    ; Evaluating argument 0
    ; Variable access: current
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL get_next_block, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    ; If statement
    ; Logical AND: BinaryOp(op=NE, left=Variable(name=next, type=LONG), right=Literal(value=0, type=LONG)) && BinaryOp(op=EQ, left=Variable(name=next, type=LONG), right=BinaryOp(op=ADD, left=Variable(name=current, type=LONG), right=Variable(name=current_size, type=LONG)))
    ; Comparison: Variable(name=next, type=LONG) NE Literal(value=0, type=LONG)
    ; Variable access: next
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 == t0
    JZ else_43, t2
    ; Comparison: Variable(name=next, type=LONG) EQ BinaryOp(op=ADD, left=Variable(name=current, type=LONG), right=Variable(name=current_size, type=LONG))
    ; Variable access: next
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    ; Arithmetic operation: ADD
    ; Variable access: current
    LDI t2, -8
    ADD t2, fp, t2
    LD t3, t2
    ; Variable access: current_size
    LDI t2, -16
    ADD t2, fp, t2
    LD t4, t2
    ADD t0, t3, t4
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_43, t2
    ; Variable declaration: next_size
    ; Function call: get_block_size
    ; Preparing function call: get_block_size
    ; Evaluating argument 0
    ; Variable access: next
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL get_block_size, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -32
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: next_next
    ; Function call: get_next_block
    ; Preparing function call: get_next_block
    ; Evaluating argument 0
    ; Variable access: next
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL get_next_block, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -40
    ADD t1, fp, t1
    ST t1, t0
    ; Expression statement
    ; Function call: set_header
    ; Preparing function call: set_header
    ; Evaluating argument 0
    ; Variable access: current
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Arithmetic operation: ADD
    ; Variable access: current_size
    LDI t2, -16
    ADD t2, fp, t2
    LD t3, t2
    ; Variable access: next_size
    LDI t2, -32
    ADD t2, fp, t2
    LD t4, t2
    ADD t0, t3, t4
    ; Evaluating argument 2
    ; Variable access: next_next
    LDI t2, -40
    ADD t2, fp, t2
    LD t3, t2
    PUSH t3
    PUSH t0
    PUSH t1
    JAL set_header, ra
    LDI t0, 24
    ADD sp, sp, t0
    ; Cleaned up 3 arguments from stack
    MOV t0, a0
    JMP endif_44
else_43:
    ; Variable assignment: current
    ; Variable access: next
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, -8
    ADD t0, fp, t0
    ST t0, t1
endif_44:
    JMP loop_41
endloop_42:
    ; Function epilogue
coalesce_free_blocks_end_38:
    LDI t0, 40
    ADD sp, sp, t0
    ; Deallocated 40 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ======================================
    ; Function: free
    ; ======================================
free:
    ; Pre-allocating 2 local variables
    ; Pre-allocated variable: header_addr (LONG)
    ; Pre-allocated variable: block_size (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 16 bytes
    LDI t0, 16
    SUB sp, sp, t0
    ; Allocated 16 bytes for stack frame
    ; If statement
    ; Arithmetic operation: AND
    ; Unary operation: NOT
    ; Function call: is_valid_ptr
    ; Preparing function call: is_valid_ptr
    ; Saving 1 live temporaries
    PUSH t0
    ; Evaluating argument 0
    ; Variable access: ptr
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    PUSH t2
    JAL is_valid_ptr, ra
    LDI t1, 8
    ADD sp, sp, t1
    ; Cleaned up 1 arguments from stack
    MOV t1, a0
    ; Restoring 1 saved temporaries
    POP t0
    NOT t2, t1
    ; Literal value: 1
    LDI t1, 1
    AND t0, t2, t1
    JZ else_46, t0
    ; Return statement
    JMP free_end_45
else_46:
    ; Variable declaration: header_addr
    ; Arithmetic operation: SUB
    ; Variable access: ptr
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: HEADER_SIZE
    LDI t1, 16
    ADD t1, gp, t1
    LD t3, t1
    SUB t0, t2, t3
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: block_size
    ; Function call: get_block_size
    ; Preparing function call: get_block_size
    ; Evaluating argument 0
    ; Variable access: header_addr
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL get_block_size, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; Expression statement
    ; Function call: set_header
    ; Preparing function call: set_header
    ; Evaluating argument 0
    ; Variable access: header_addr
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: block_size
    LDI t0, -16
    ADD t0, fp, t0
    LD t2, t0
    ; Evaluating argument 2
    ; Variable access: freeListHead
    LDI t0, 40
    ADD t0, gp, t0
    LD t3, t0
    PUSH t3
    PUSH t2
    PUSH t1
    JAL set_header, ra
    LDI t0, 24
    ADD sp, sp, t0
    ; Cleaned up 3 arguments from stack
    MOV t0, a0
    ; Variable assignment: freeListHead
    ; Variable access: header_addr
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 40
    ADD t0, gp, t0
    ST t0, t1
    ; Expression statement
    ; Function call: coalesce_free_blocks
    ; Preparing function call: coalesce_free_blocks
    JAL coalesce_free_blocks, ra
    MOV t0, a0
    ; Function epilogue
free_end_45:
    LDI t0, 16
    ADD sp, sp, t0
    ; Deallocated 16 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ===================================
    ; Function: realloc
    ; ===================================
realloc:
    ; Pre-allocating 6 local variables
    ; Pre-allocated variable: header_addr (LONG)
    ; Pre-allocated variable: current_size (LONG)
    ; Pre-allocated variable: aligned_new_size (LONG)
    ; Pre-allocated variable: new_ptr (LONG)
    ; Pre-allocated variable: copy_size (LONG)
    ; Pre-allocated variable: i (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 48 bytes
    LDI t0, 48
    SUB sp, sp, t0
    ; Allocated 48 bytes for stack frame
    ; If statement
    ; Comparison: Variable(name=ptr, type=LONG) EQ Literal(value=0, type=LONG)
    ; Variable access: ptr
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_49, t2
    ; Return statement
    ; Function call: malloc
    ; Preparing function call: malloc
    ; Evaluating argument 0
    ; Variable access: new_size
    LDI t0, 24
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL malloc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    MOV a0, t0
    JMP realloc_end_48
else_49:
    ; If statement
    ; Comparison: Variable(name=new_size, type=LONG) EQ Literal(value=0, type=LONG)
    ; Variable access: new_size
    LDI t0, 24
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_51, t2
    ; Expression statement
    ; Function call: free
    ; Preparing function call: free
    ; Evaluating argument 0
    ; Variable access: ptr
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL free, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Return statement
    ; Literal value: 0
    LDI t0, 0
    MOV a0, t0
    JMP realloc_end_48
else_51:
    ; If statement
    ; Arithmetic operation: AND
    ; Unary operation: NOT
    ; Function call: is_valid_ptr
    ; Preparing function call: is_valid_ptr
    ; Saving 1 live temporaries
    PUSH t0
    ; Evaluating argument 0
    ; Variable access: ptr
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    PUSH t2
    JAL is_valid_ptr, ra
    LDI t1, 8
    ADD sp, sp, t1
    ; Cleaned up 1 arguments from stack
    MOV t1, a0
    ; Restoring 1 saved temporaries
    POP t0
    NOT t2, t1
    ; Literal value: 1
    LDI t1, 1
    AND t0, t2, t1
    JZ else_53, t0
    ; Return statement
    ; Literal value: 0
    LDI t0, 0
    MOV a0, t0
    JMP realloc_end_48
else_53:
    ; Variable declaration: header_addr
    ; Arithmetic operation: SUB
    ; Variable access: ptr
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: HEADER_SIZE
    LDI t1, 16
    ADD t1, gp, t1
    LD t3, t1
    SUB t0, t2, t3
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: current_size
    ; Arithmetic operation: SUB
    ; Function call: get_block_size
    ; Preparing function call: get_block_size
    ; Saving 1 live temporaries
    PUSH t0
    ; Evaluating argument 0
    ; Variable access: header_addr
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    PUSH t2
    JAL get_block_size, ra
    LDI t1, 8
    ADD sp, sp, t1
    ; Cleaned up 1 arguments from stack
    MOV t1, a0
    ; Restoring 1 saved temporaries
    POP t0
    ; Variable access: HEADER_SIZE
    LDI t2, 16
    ADD t2, gp, t2
    LD t3, t2
    SUB t0, t1, t3
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: aligned_new_size
    ; Function call: align_up
    ; Preparing function call: align_up
    ; Evaluating argument 0
    ; Variable access: new_size
    LDI t0, 24
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: ALIGNMENT
    LDI t0, 32
    ADD t0, gp, t0
    LD t2, t0
    PUSH t2
    PUSH t1
    JAL align_up, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    ; If statement
    ; Comparison: Variable(name=aligned_new_size, type=LONG) LE Variable(name=current_size, type=LONG)
    ; Variable access: aligned_new_size
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    ; Variable access: current_size
    LDI t0, -16
    ADD t0, fp, t0
    LD t2, t0
    SUB t0, t1, t2
    ; Jump if t1 > t2
    JPP else_55, t0
    ; Return statement
    ; Variable access: ptr
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    MOV a0, t1
    JMP realloc_end_48
else_55:
    ; Variable declaration: new_ptr
    ; Function call: malloc
    ; Preparing function call: malloc
    ; Evaluating argument 0
    ; Variable access: new_size
    LDI t0, 24
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL malloc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -32
    ADD t1, fp, t1
    ST t1, t0
    ; If statement
    ; Comparison: Variable(name=new_ptr, type=LONG) EQ Literal(value=0, type=LONG)
    ; Variable access: new_ptr
    LDI t0, -32
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_57, t2
    ; Return statement
    ; Literal value: 0
    LDI t0, 0
    MOV a0, t0
    JMP realloc_end_48
else_57:
    ; Variable declaration: copy_size
    ; Variable access: current_size
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, -40
    ADD t0, fp, t0
    ST t0, t1
    ; If statement
    ; Comparison: Variable(name=aligned_new_size, type=LONG) LT Variable(name=copy_size, type=LONG)
    ; Variable access: aligned_new_size
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    ; Variable access: copy_size
    LDI t0, -40
    ADD t0, fp, t0
    LD t2, t0
    SUB t0, t1, t2
    ; Jump if t1 >= t2
    JPN skip_ge_61, t0
    JMP else_59
skip_ge_61:
    ; Variable assignment: copy_size
    ; Variable access: aligned_new_size
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, -40
    ADD t0, fp, t0
    ST t0, t1
else_59:
    ; Variable declaration: i
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -48
    ADD t1, fp, t1
    ST t1, t0
    ; While loop
loop_62:
    ; Comparison: Variable(name=i, type=LONG) LT Variable(name=copy_size, type=LONG)
    ; Variable access: i
    LDI t0, -48
    ADD t0, fp, t0
    LD t1, t0
    ; Variable access: copy_size
    LDI t0, -40
    ADD t0, fp, t0
    LD t2, t0
    SUB t0, t1, t2
    ; Jump if t1 >= t2
    JPN skip_ge_64, t0
    JMP endloop_63
skip_ge_64:
    ; Arithmetic operation: ADD
    ; Variable access: new_ptr
    LDI t1, -32
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: i
    LDI t1, -48
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    ; Dereference assignment to address: t0
    ; Dereference operation
    ; Arithmetic operation: ADD
    ; Variable access: ptr
    LDI t3, 16
    ADD t3, fp, t3
    LD t4, t3
    ; Variable access: i
    LDI t3, -48
    ADD t3, fp, t3
    LD t5, t3
    ADD t2, t4, t5
    LD t1, t2
    ; Store LONG to address t0
    ST t0, t1
    ; Variable assignment: i
    ; Arithmetic operation: ADD
    ; Variable access: i
    LDI t1, -48
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -48
    ADD t1, fp, t1
    ST t1, t0
    JMP loop_62
endloop_63:
    ; Expression statement
    ; Function call: free
    ; Preparing function call: free
    ; Evaluating argument 0
    ; Variable access: ptr
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL free, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Return statement
    ; Variable access: new_ptr
    LDI t0, -32
    ADD t0, fp, t0
    LD t1, t0
    MOV a0, t1
    JMP realloc_end_48
    ; Function epilogue
realloc_end_48:
    LDI t0, 48
    ADD sp, sp, t0
    ; Deallocated 48 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ====================================
    ; Function: calloc
    ; ====================================
calloc:
    ; Pre-allocating 3 local variables
    ; Pre-allocated variable: total_size (LONG)
    ; Pre-allocated variable: ptr (LONG)
    ; Pre-allocated variable: i (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 24 bytes
    LDI t0, 24
    SUB sp, sp, t0
    ; Allocated 24 bytes for stack frame
    ; Variable declaration: total_size
    ; Arithmetic operation: MUL
    ; Variable access: count
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: size
    LDI t1, 24
    ADD t1, fp, t1
    LD t3, t1
    MUL t0, t2, t3
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: ptr
    ; Function call: malloc
    ; Preparing function call: malloc
    ; Evaluating argument 0
    ; Variable access: total_size
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL malloc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; If statement
    ; Comparison: Variable(name=ptr, type=LONG) EQ Literal(value=0, type=LONG)
    ; Variable access: ptr
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_66, t2
    ; Return statement
    ; Literal value: 0
    LDI t0, 0
    MOV a0, t0
    JMP calloc_end_65
else_66:
    ; Variable declaration: i
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    ; While loop
loop_68:
    ; Comparison: Variable(name=i, type=LONG) LT Variable(name=total_size, type=LONG)
    ; Variable access: i
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    ; Variable access: total_size
    LDI t0, -8
    ADD t0, fp, t0
    LD t2, t0
    SUB t0, t1, t2
    ; Jump if t1 >= t2
    JPN skip_ge_70, t0
    JMP endloop_69
skip_ge_70:
    ; Arithmetic operation: ADD
    ; Variable access: ptr
    LDI t1, -16
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: i
    LDI t1, -24
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    ; Dereference assignment to address: t0
    ; Literal value: 0
    LDI t1, 0
    ; Store LONG to address t0
    ST t0, t1
    ; Variable assignment: i
    ; Arithmetic operation: ADD
    ; Variable access: i
    LDI t1, -24
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    JMP loop_68
endloop_69:
    ; Return statement
    ; Variable access: ptr
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    MOV a0, t1
    JMP calloc_end_65
    ; Function epilogue
calloc_end_65:
    LDI t0, 24
    ADD sp, sp, t0
    ; Deallocated 24 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ============================
    ; Function: get_heap_stats
    ; ============================
get_heap_stats:
    ; Pre-allocating 1 local variables
    ; Pre-allocated variable: current (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 8 bytes
    LDI t0, 8
    SUB sp, sp, t0
    ; Allocated 8 bytes for stack frame
    ; Variable access: total_free
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    ; Dereference assignment to address: t1
    ; Literal value: 0
    LDI t0, 0
    ; Store LONG to address t1
    ST t1, t0
    ; Variable access: total_allocated
    LDI t0, 24
    ADD t0, fp, t0
    LD t1, t0
    ; Dereference assignment to address: t1
    ; Literal value: 0
    LDI t0, 0
    ; Store LONG to address t1
    ST t1, t0
    ; Variable access: free_blocks
    LDI t0, 32
    ADD t0, fp, t0
    LD t1, t0
    ; Dereference assignment to address: t1
    ; Literal value: 0
    LDI t0, 0
    ; Store LONG to address t1
    ST t1, t0
    ; Variable declaration: current
    ; Variable access: freeListHead
    LDI t0, 40
    ADD t0, gp, t0
    LD t1, t0
    LDI t0, -8
    ADD t0, fp, t0
    ST t0, t1
    ; While loop
loop_72:
    ; Comparison: Variable(name=current, type=LONG) NE Literal(value=0, type=LONG)
    ; Variable access: current
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 == t0
    JZ endloop_73, t2
    ; Variable access: total_free
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    ; Dereference assignment to address: t1
    ; Arithmetic operation: ADD
    ; Dereference operation
    ; Variable access: total_free
    LDI t3, 16
    ADD t3, fp, t3
    LD t4, t3
    LD t2, t4
    ; Function call: get_block_size
    ; Preparing function call: get_block_size
    ; Saving 3 live temporaries
    PUSH t2
    PUSH t1
    PUSH t0
    ; Evaluating argument 0
    ; Variable access: current
    LDI t3, -8
    ADD t3, fp, t3
    LD t4, t3
    PUSH t4
    JAL get_block_size, ra
    LDI t3, 8
    ADD sp, sp, t3
    ; Cleaned up 1 arguments from stack
    MOV t3, a0
    ; Restoring 3 saved temporaries
    POP t0
    POP t1
    POP t2
    ADD t0, t2, t3
    ; Store LONG to address t1
    ST t1, t0
    ; Variable access: free_blocks
    LDI t0, 32
    ADD t0, fp, t0
    LD t1, t0
    ; Dereference assignment to address: t1
    ; Arithmetic operation: ADD
    ; Dereference operation
    ; Variable access: free_blocks
    LDI t3, 32
    ADD t3, fp, t3
    LD t4, t3
    LD t2, t4
    ; Literal value: 1
    LDI t3, 1
    ADD t0, t2, t3
    ; Store LONG to address t1
    ST t1, t0
    ; Variable assignment: current
    ; Function call: get_next_block
    ; Preparing function call: get_next_block
    ; Evaluating argument 0
    ; Variable access: current
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL get_next_block, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    JMP loop_72
endloop_73:
    ; Variable access: total_allocated
    LDI t0, 24
    ADD t0, fp, t0
    LD t1, t0
    ; Dereference assignment to address: t1
    ; Arithmetic operation: SUB
    ; Variable access: HEAP_SIZE
    LDI t2, 8
    ADD t2, gp, t2
    LD t3, t2
    ; Dereference operation
    ; Variable access: total_free
    LDI t4, 16
    ADD t4, fp, t4
    LD t5, t4
    LD t2, t5
    SUB t0, t3, t2
    ; Store LONG to address t1
    ST t1, t0
    ; Function epilogue
get_heap_stats_end_71:
    LDI t0, 8
    ADD sp, sp, t0
    ; Deallocated 8 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ======================================
    ; Function: main
    ; ======================================
main:
    ; Pre-allocating 3 local variables
    ; Pre-allocated variable: s (PointerType[elementType=StructType[name=TestStruct, fields=[Field[name=a, type=LONG], Field[name=b, type=PointerType[elementType=BYTE]], Field[name=c, type=PointerType[elementType=PointerType[elementType=INT]]]]]])
    ; Pre-allocated variable: child1 (PointerType[elementType=INT])
    ; Pre-allocated variable: child2 (PointerType[elementType=INT])
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 24 bytes
    LDI t0, 24
    SUB sp, sp, t0
    ; Allocated 24 bytes for stack frame
    ; Variable declaration: s
    ; Function call: malloc
    ; Preparing function call: malloc
    ; Evaluating argument 0
    ; Literal value: 24
    LDI t0, 24
    PUSH t0
    JAL malloc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Struct field assignment: a
    ; Variable access: s
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 0
    ADD t0, t1, t0
    ; Literal value: 1134535329160539614
    LDI t2, 1134535329160539614
    ST t0, t2
    ; Struct field assignment: b
    ; Variable access: s
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 8
    ADD t0, t1, t0
    ; Function call: calloc
    ; Preparing function call: calloc
    ; Saving 2 live temporaries
    PUSH t1
    PUSH t0
    ; Evaluating argument 0
    ; Literal value: 8
    LDI t2, 8
    ; Evaluating argument 1
    ; Literal value: 1
    LDI t3, 1
    PUSH t3
    PUSH t2
    JAL calloc, ra
    LDI t2, 16
    ADD sp, sp, t2
    ; Cleaned up 2 arguments from stack
    MOV t2, a0
    ; Restoring 2 saved temporaries
    POP t0
    POP t1
    ST t0, t2
    ; Struct field access: b
    ; Variable access: s
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    LDI t2, 8
    ADD t2, t1, t2
    LD t0, t2
    ; Dereference assignment to address: t0
    ; Storing array literal to memory at t0
    LDI t1, 0
    ADD t2, t0, t1
    ; Literal value: 1
    LDI t3, 1
    SB t2, t3
    LDI t1, 1
    ADD t2, t0, t1
    ; Literal value: 2
    LDI t3, 2
    SB t2, t3
    LDI t1, 2
    ADD t2, t0, t1
    ; Literal value: 3
    LDI t3, 3
    SB t2, t3
    LDI t1, 3
    ADD t2, t0, t1
    ; Literal value: 4
    LDI t3, 4
    SB t2, t3
    ; Struct field access: b
    ; Variable access: s
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    LDI t2, 8
    ADD t2, t1, t2
    LD t0, t2
    ; Literal value: 4
    LDI t1, 4
    ; Literal value: 5
    LDI t2, 5
    ; Array index assignment
    LDI t3, 1
    MUL t3, t1, t3
    ADD t4, t0, t3
    SB t4, t2
    ; Struct field access: b
    ; Variable access: s
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    LDI t2, 8
    ADD t2, t1, t2
    LD t0, t2
    ; Literal value: 5
    LDI t1, 5
    ; Arithmetic operation: ADD
    ; Array indexing operation
    ; Struct field access: b
    ; Variable access: s
    LDI t3, -8
    ADD t3, fp, t3
    LD t4, t3
    LDI t5, 8
    ADD t5, t4, t5
    LD t3, t5
    ; Literal value: 4
    LDI t4, 4
    LDI t6, 1
    MUL t6, t4, t6
    ADD t7, t3, t6
    LB t5, t7
    ; Literal value: 1
    LDI t3, 1
    ADD t2, t5, t3
    ; Array index assignment
    LDI t3, 1
    MUL t3, t1, t3
    ADD t4, t0, t3
    SB t4, t2
    ; Arithmetic operation: ADD
    ; Struct field access: b
    ; Variable access: s
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    LDI t3, 8
    ADD t3, t2, t3
    LD t1, t3
    ; Literal value: 6
    LDI t2, 6
    ADD t0, t1, t2
    ; Dereference assignment to address: t0
    ; Literal value: 7
    LDI t1, 7
    ; Store LONG to address t0
    ST t0, t1
    ; Struct field access: b
    ; Variable access: s
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    LDI t2, 8
    ADD t2, t1, t2
    LD t0, t2
    ; Literal value: 7
    LDI t1, 7
    ; Arithmetic operation: ADD
    ; Dereference operation
    ; Arithmetic operation: ADD
    ; Struct field access: b
    ; Variable access: s
    LDI t5, -8
    ADD t5, fp, t5
    LD t6, t5
    LDI t7, 8
    ADD t7, t6, t7
    LD t5, t7
    ; Literal value: 6
    LDI t6, 6
    ADD t4, t5, t6
    LB t3, t4
    ; Literal value: 1
    LDI t4, 1
    ADD t2, t3, t4
    ; Array index assignment
    LDI t3, 1
    MUL t3, t1, t3
    ADD t4, t0, t3
    SB t4, t2
    ; Struct field assignment: c
    ; Variable access: s
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 16
    ADD t0, t1, t0
    ; Function call: calloc
    ; Preparing function call: calloc
    ; Saving 2 live temporaries
    PUSH t1
    PUSH t0
    ; Evaluating argument 0
    ; Literal value: 4
    LDI t2, 4
    ; Evaluating argument 1
    ; Literal value: 4
    LDI t3, 4
    PUSH t3
    PUSH t2
    JAL calloc, ra
    LDI t2, 16
    ADD sp, sp, t2
    ; Cleaned up 2 arguments from stack
    MOV t2, a0
    ; Restoring 2 saved temporaries
    POP t0
    POP t1
    ST t0, t2
    ; Variable declaration: child1
    ; Function call: calloc
    ; Preparing function call: calloc
    ; Evaluating argument 0
    ; Literal value: 4
    LDI t0, 4
    ; Evaluating argument 1
    ; Literal value: 4
    LDI t1, 4
    PUSH t1
    PUSH t0
    JAL calloc, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; Variable access: child1
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    ; Dereference assignment to address: t1
    ; Storing array literal to memory at t1
    LDI t0, 0
    ADD t2, t1, t0
    ; Literal value: 255
    LDI t3, 255
    SI t2, t3
    LDI t0, 4
    ADD t2, t1, t0
    ; Literal value: 170
    LDI t3, 170
    SI t2, t3
    LDI t0, 8
    ADD t2, t1, t0
    ; Literal value: 255
    LDI t3, 255
    SI t2, t3
    LDI t0, 12
    ADD t2, t1, t0
    ; Literal value: 170
    LDI t3, 170
    SI t2, t3
    ; Variable declaration: child2
    ; Type conversion to PointerType[elementType=INT]
    ; Function call: calloc
    ; Preparing function call: calloc
    ; Saving 1 live temporaries
    PUSH t0
    ; Evaluating argument 0
    ; Literal value: 4
    LDI t1, 4
    ; Evaluating argument 1
    ; Literal value: 4
    LDI t2, 4
    PUSH t2
    PUSH t1
    JAL calloc, ra
    LDI t1, 16
    ADD sp, sp, t1
    ; Cleaned up 2 arguments from stack
    MOV t1, a0
    ; Restoring 1 saved temporaries
    POP t0
    ; Converting LONG to POINTER (no-op)
    MOV t0, t1
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    ; Variable access: child2
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    ; Dereference assignment to address: t1
    ; Storing array literal to memory at t1
    LDI t0, 0
    ADD t2, t1, t0
    ; Literal value: 170
    LDI t3, 170
    SI t2, t3
    LDI t0, 4
    ADD t2, t1, t0
    ; Literal value: 187
    LDI t3, 187
    SI t2, t3
    LDI t0, 8
    ADD t2, t1, t0
    ; Literal value: 204
    LDI t3, 204
    SI t2, t3
    LDI t0, 12
    ADD t2, t1, t0
    ; Literal value: 221
    LDI t3, 221
    SI t2, t3
    ; Struct field access: c
    ; Variable access: s
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    LDI t2, 16
    ADD t2, t1, t2
    LD t0, t2
    ; Dereference assignment to address: t0
    ; Storing array literal to memory at t0
    LDI t1, 0
    ADD t2, t0, t1
    ; Variable access: child1
    LDI t3, -16
    ADD t3, fp, t3
    LD t4, t3
    ST t2, t4
    LDI t1, 8
    ADD t2, t0, t1
    ; Variable access: child2
    LDI t3, -24
    ADD t3, fp, t3
    LD t4, t3
    ST t2, t4
    LDI t1, 16
    ADD t2, t0, t1
    ; Variable access: child1
    LDI t3, -16
    ADD t3, fp, t3
    LD t4, t3
    ST t2, t4
    ; While loop
loop_75:
    ; Literal value: 1
    LDI t0, 1
    JZ endloop_76, t0
    JMP loop_75
endloop_76:
    ; Return statement
    ; Literal value: 1
    LDI t0, 1
    MOV a0, t0
    JMP main_end_74
    ; Function epilogue
main_end_74:
    LDI t0, 24
    ADD sp, sp, t0
    ; Deallocated 24 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function