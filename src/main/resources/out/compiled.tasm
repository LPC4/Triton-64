    ; Program entry point
_start:

    ; ====================================
    ; Global variables
    ; ====================================
    ADD hp, gp, 56
    ; Allocated 56 bytes for global variables
    ; Total global data size: 56 bytes
    ; Literal value: 80
    LDI t0, 80
    LDI t1, 0
    ADD t1, gp, t1
    SI t1, t0
    ; Literal value: 30
    LDI t0, 30
    LDI t1, 4
    ADD t1, gp, t1
    SI t1, t0
    ; Literal value: 539099136
    LDI t0, 539099136
    LDI t1, 8
    ADD t1, gp, t1
    ST t1, t0
    ; Literal value: 0
    LDI t0, 0
    LDI t1, 16
    ADD t1, gp, t1
    SI t1, t0
    ; Literal value: 402784256
    LDI t0, 402784256
    LDI t1, 20
    ADD t1, gp, t1
    ST t1, t0
    ; Literal value: 134217728
    LDI t0, 134217728
    LDI t1, 28
    ADD t1, gp, t1
    ST t1, t0
    ; Literal value: 12
    LDI t0, 12
    LDI t1, 36
    ADD t1, gp, t1
    SI t1, t0
    ; Literal value: 16
    LDI t0, 16
    LDI t1, 40
    ADD t1, gp, t1
    SI t1, t0
    ; Literal value: 8
    LDI t0, 8
    LDI t1, 44
    ADD t1, gp, t1
    SI t1, t0
    ; Literal value: 0
    LDI t0, 0
    LDI t1, 48
    ADD t1, gp, t1
    ST t1, t0
    JAL main, ra
    HLT

    ; ==============================
    ; Function: console_init
    ; ==============================
console_init:
    ; Pre-allocating 0 local variables
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 0 bytes
    ; Variable assignment: console_cursor
    ; Literal value: 0
    LDI t0, 0
    LDI t1, 16
    ADD t1, gp, t1
    SI t1, t0
    ; Expression statement
    ; Function call: console_clear
    ; Preparing function call: console_clear
    JAL console_clear, ra
    MOV t0, a0
    ; Function epilogue
console_init_end_0:
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; =============================
    ; Function: console_clear
    ; =============================
console_clear:
    ; Pre-allocating 4 local variables
    ; Pre-allocated variable: i (INT)
    ; Pre-allocated variable: total_chars (INT)
    ; Pre-allocated variable: fb (LONG)
    ; Pre-allocated variable: cell (PointerType[elementType=StructType{name='ColorChar', complete=true}])
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 24 bytes
    LDI t0, 24
    SUB sp, sp, t0
    ; Allocated 24 bytes for stack frame
    ; Variable declaration: i
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -4
    ADD t1, fp, t1
    SI t1, t0
    ; Variable declaration: total_chars
    ; Arithmetic operation: MUL
    ; Variable access: SCREEN_WIDTH
    LDI t1, 0
    ADD t1, gp, t1
    LI t2, t1
    ; Variable access: SCREEN_HEIGHT
    LDI t1, 4
    ADD t1, gp, t1
    LI t3, t1
    MUL t0, t2, t3
    LDI t1, -8
    ADD t1, fp, t1
    SI t1, t0
    ; Variable declaration: fb
    ; Variable access: FRAMEBUFFER_BASE
    LDI t0, 8
    ADD t0, gp, t0
    LD t1, t0
    LDI t0, -16
    ADD t0, fp, t0
    ST t0, t1
    ; While loop
loop_2:
    ; Comparison: Variable(name=i, type=INT) LT Variable(name=total_chars, type=INT)
    ; Variable access: i
    LDI t0, -4
    ADD t0, fp, t0
    LI t1, t0
    ; Variable access: total_chars
    LDI t0, -8
    ADD t0, fp, t0
    LI t2, t0
    SUB t0, t1, t2
    ; Jump if t1 >= t2
    JPN skip_ge_4, t0
    JMP endloop_3
skip_ge_4:
    ; Variable declaration: cell
    ; Type conversion to PointerType[elementType=StructType{name='ColorChar', complete=true}]
    ; Arithmetic operation: ADD
    ; Variable access: fb
    LDI t2, -16
    ADD t2, fp, t2
    LD t3, t2
    ; Arithmetic operation: MUL
    ; Variable access: i
    LDI t4, -4
    ADD t4, fp, t4
    LI t5, t4
    ; Literal value: 4
    LDI t4, 4
    MUL t2, t5, t4
    ADD t1, t3, t2
    ; Converting LONG to POINTER (no-op)
    MOV t0, t1
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    ; Struct field assignment: ch
    ; Variable access: cell
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 0
    ADD t0, t1, t0
    ; Literal value: 32
    LDI t2, 32
    SB t0, t2
    ; Struct field assignment: fg
    ; Variable access: cell
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 1
    ADD t0, t1, t0
    ; Literal value: 15
    LDI t2, 15
    SB t0, t2
    ; Struct field assignment: bg
    ; Variable access: cell
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 2
    ADD t0, t1, t0
    ; Literal value: 0
    LDI t2, 0
    SB t0, t2
    ; Struct field assignment: reserved
    ; Variable access: cell
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 3
    ADD t0, t1, t0
    ; Literal value: 0
    LDI t2, 0
    SB t0, t2
    ; Variable assignment: i
    ; Arithmetic operation: ADD
    ; Variable access: i
    LDI t1, -4
    ADD t1, fp, t1
    LI t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -4
    ADD t1, fp, t1
    SI t1, t0
    JMP loop_2
endloop_3:
    ; Variable assignment: console_cursor
    ; Literal value: 0
    LDI t0, 0
    LDI t1, 16
    ADD t1, gp, t1
    SI t1, t0
    ; Function epilogue
console_clear_end_1:
    LDI t0, 24
    ADD sp, sp, t0
    ; Deallocated 24 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ============================
    ; Function: console_scroll
    ; ============================
console_scroll:
    ; Pre-allocating 10 local variables
    ; Pre-allocated variable: fb (LONG)
    ; Pre-allocated variable: row (INT)
    ; Pre-allocated variable: col (INT)
    ; Pre-allocated variable: src_index (INT)
    ; Pre-allocated variable: dst_index (INT)
    ; Pre-allocated variable: src (PointerType[elementType=StructType{name='ColorChar', complete=true}])
    ; Pre-allocated variable: dst (PointerType[elementType=StructType{name='ColorChar', complete=true}])
    ; Pre-allocated variable: col (INT)
    ; Pre-allocated variable: index (INT)
    ; Pre-allocated variable: cell (PointerType[elementType=StructType{name='ColorChar', complete=true}])
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 56 bytes
    LDI t0, 56
    SUB sp, sp, t0
    ; Allocated 56 bytes for stack frame
    ; Variable declaration: fb
    ; Variable access: FRAMEBUFFER_BASE
    LDI t0, 8
    ADD t0, gp, t0
    LD t1, t0
    LDI t0, -8
    ADD t0, fp, t0
    ST t0, t1
    ; Variable declaration: row
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -12
    ADD t1, fp, t1
    SI t1, t0
    ; While loop
loop_6:
    ; Comparison: Variable(name=row, type=INT) LT BinaryOp(op=SUB, left=Variable(name=SCREEN_HEIGHT, type=INT), right=Literal(value=1, type=LONG))
    ; Variable access: row
    LDI t0, -12
    ADD t0, fp, t0
    LI t1, t0
    ; Arithmetic operation: SUB
    ; Variable access: SCREEN_HEIGHT
    LDI t2, 4
    ADD t2, gp, t2
    LI t3, t2
    ; Literal value: 1
    LDI t2, 1
    SUB t0, t3, t2
    SUB t2, t1, t0
    ; Jump if t1 >= t0
    JPN skip_ge_8, t2
    JMP endloop_7
skip_ge_8:
    ; Variable declaration: col
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -16
    ADD t1, fp, t1
    SI t1, t0
    ; While loop
loop_9:
    ; Comparison: Variable(name=col, type=INT) LT Variable(name=SCREEN_WIDTH, type=INT)
    ; Variable access: col
    LDI t0, -16
    ADD t0, fp, t0
    LI t1, t0
    ; Variable access: SCREEN_WIDTH
    LDI t0, 0
    ADD t0, gp, t0
    LI t2, t0
    SUB t0, t1, t2
    ; Jump if t1 >= t2
    JPN skip_ge_11, t0
    JMP endloop_10
skip_ge_11:
    ; Variable declaration: src_index
    ; Arithmetic operation: ADD
    ; Arithmetic operation: MUL
    ; Arithmetic operation: ADD
    ; Variable access: row
    LDI t3, -12
    ADD t3, fp, t3
    LI t4, t3
    ; Literal value: 1
    LDI t3, 1
    ADD t2, t4, t3
    ; Variable access: SCREEN_WIDTH
    LDI t3, 0
    ADD t3, gp, t3
    LI t4, t3
    MUL t1, t2, t4
    ; Variable access: col
    LDI t2, -16
    ADD t2, fp, t2
    LI t3, t2
    ADD t0, t1, t3
    LDI t1, -20
    ADD t1, fp, t1
    SI t1, t0
    ; Variable declaration: dst_index
    ; Arithmetic operation: ADD
    ; Arithmetic operation: MUL
    ; Variable access: row
    LDI t2, -12
    ADD t2, fp, t2
    LI t3, t2
    ; Variable access: SCREEN_WIDTH
    LDI t2, 0
    ADD t2, gp, t2
    LI t4, t2
    MUL t1, t3, t4
    ; Variable access: col
    LDI t2, -16
    ADD t2, fp, t2
    LI t3, t2
    ADD t0, t1, t3
    LDI t1, -24
    ADD t1, fp, t1
    SI t1, t0
    ; Variable declaration: src
    ; Type conversion to PointerType[elementType=StructType{name='ColorChar', complete=true}]
    ; Arithmetic operation: ADD
    ; Variable access: fb
    LDI t2, -8
    ADD t2, fp, t2
    LD t3, t2
    ; Arithmetic operation: MUL
    ; Variable access: src_index
    LDI t4, -20
    ADD t4, fp, t4
    LI t5, t4
    ; Literal value: 4
    LDI t4, 4
    MUL t2, t5, t4
    ADD t1, t3, t2
    ; Converting LONG to POINTER (no-op)
    MOV t0, t1
    LDI t1, -32
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: dst
    ; Type conversion to PointerType[elementType=StructType{name='ColorChar', complete=true}]
    ; Arithmetic operation: ADD
    ; Variable access: fb
    LDI t2, -8
    ADD t2, fp, t2
    LD t3, t2
    ; Arithmetic operation: MUL
    ; Variable access: dst_index
    LDI t4, -24
    ADD t4, fp, t4
    LI t5, t4
    ; Literal value: 4
    LDI t4, 4
    MUL t2, t5, t4
    ADD t1, t3, t2
    ; Converting LONG to POINTER (no-op)
    MOV t0, t1
    LDI t1, -40
    ADD t1, fp, t1
    ST t1, t0
    ; Struct field assignment: ch
    ; Variable access: dst
    LDI t0, -40
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 0
    ADD t0, t1, t0
    ; Struct field access: ch
    ; Variable access: src
    LDI t2, -32
    ADD t2, fp, t2
    LD t3, t2
    LDI t4, 0
    ADD t4, t3, t4
    LB t2, t4
    SB t0, t2
    ; Struct field assignment: fg
    ; Variable access: dst
    LDI t0, -40
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 1
    ADD t0, t1, t0
    ; Struct field access: fg
    ; Variable access: src
    LDI t2, -32
    ADD t2, fp, t2
    LD t3, t2
    LDI t4, 1
    ADD t4, t3, t4
    LB t2, t4
    SB t0, t2
    ; Struct field assignment: bg
    ; Variable access: dst
    LDI t0, -40
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 2
    ADD t0, t1, t0
    ; Struct field access: bg
    ; Variable access: src
    LDI t2, -32
    ADD t2, fp, t2
    LD t3, t2
    LDI t4, 2
    ADD t4, t3, t4
    LB t2, t4
    SB t0, t2
    ; Struct field assignment: reserved
    ; Variable access: dst
    LDI t0, -40
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 3
    ADD t0, t1, t0
    ; Struct field access: reserved
    ; Variable access: src
    LDI t2, -32
    ADD t2, fp, t2
    LD t3, t2
    LDI t4, 3
    ADD t4, t3, t4
    LB t2, t4
    SB t0, t2
    ; Variable assignment: col
    ; Arithmetic operation: ADD
    ; Variable access: col
    LDI t1, -16
    ADD t1, fp, t1
    LI t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -16
    ADD t1, fp, t1
    SI t1, t0
    JMP loop_9
endloop_10:
    ; Variable assignment: row
    ; Arithmetic operation: ADD
    ; Variable access: row
    LDI t1, -12
    ADD t1, fp, t1
    LI t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -12
    ADD t1, fp, t1
    SI t1, t0
    JMP loop_6
endloop_7:
    ; Variable declaration: col
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -16
    ADD t1, fp, t1
    SI t1, t0
    ; While loop
loop_12:
    ; Comparison: Variable(name=col, type=INT) LT Variable(name=SCREEN_WIDTH, type=INT)
    ; Variable access: col
    LDI t0, -16
    ADD t0, fp, t0
    LI t1, t0
    ; Variable access: SCREEN_WIDTH
    LDI t0, 0
    ADD t0, gp, t0
    LI t2, t0
    SUB t0, t1, t2
    ; Jump if t1 >= t2
    JPN skip_ge_14, t0
    JMP endloop_13
skip_ge_14:
    ; Variable declaration: index
    ; Arithmetic operation: ADD
    ; Arithmetic operation: MUL
    ; Arithmetic operation: SUB
    ; Variable access: SCREEN_HEIGHT
    LDI t3, 4
    ADD t3, gp, t3
    LI t4, t3
    ; Literal value: 1
    LDI t3, 1
    SUB t2, t4, t3
    ; Variable access: SCREEN_WIDTH
    LDI t3, 0
    ADD t3, gp, t3
    LI t4, t3
    MUL t1, t2, t4
    ; Variable access: col
    LDI t2, -16
    ADD t2, fp, t2
    LI t3, t2
    ADD t0, t1, t3
    LDI t1, -44
    ADD t1, fp, t1
    SI t1, t0
    ; Variable declaration: cell
    ; Type conversion to PointerType[elementType=StructType{name='ColorChar', complete=true}]
    ; Arithmetic operation: ADD
    ; Variable access: fb
    LDI t2, -8
    ADD t2, fp, t2
    LD t3, t2
    ; Arithmetic operation: MUL
    ; Variable access: index
    LDI t4, -44
    ADD t4, fp, t4
    LI t5, t4
    ; Literal value: 4
    LDI t4, 4
    MUL t2, t5, t4
    ADD t1, t3, t2
    ; Converting LONG to POINTER (no-op)
    MOV t0, t1
    LDI t1, -52
    ADD t1, fp, t1
    ST t1, t0
    ; Struct field assignment: ch
    ; Variable access: cell
    LDI t0, -52
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 0
    ADD t0, t1, t0
    ; Literal value: 32
    LDI t2, 32
    SB t0, t2
    ; Struct field assignment: fg
    ; Variable access: cell
    LDI t0, -52
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 1
    ADD t0, t1, t0
    ; Literal value: 15
    LDI t2, 15
    SB t0, t2
    ; Struct field assignment: bg
    ; Variable access: cell
    LDI t0, -52
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 2
    ADD t0, t1, t0
    ; Literal value: 0
    LDI t2, 0
    SB t0, t2
    ; Struct field assignment: reserved
    ; Variable access: cell
    LDI t0, -52
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 3
    ADD t0, t1, t0
    ; Literal value: 0
    LDI t2, 0
    SB t0, t2
    ; Variable assignment: col
    ; Arithmetic operation: ADD
    ; Variable access: col
    LDI t1, -16
    ADD t1, fp, t1
    LI t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -16
    ADD t1, fp, t1
    SI t1, t0
    JMP loop_12
endloop_13:
    ; Function epilogue
console_scroll_end_5:
    LDI t0, 56
    ADD sp, sp, t0
    ; Deallocated 56 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ==============================
    ; Function: console_putc
    ; ==============================
console_putc:
    ; Pre-allocating 3 local variables
    ; Pre-allocated variable: fb (LONG)
    ; Pre-allocated variable: row (INT)
    ; Pre-allocated variable: cell (PointerType[elementType=StructType{name='ColorChar', complete=true}])
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 24 bytes
    LDI t0, 24
    SUB sp, sp, t0
    ; Allocated 24 bytes for stack frame
    ; Variable declaration: fb
    ; Variable access: FRAMEBUFFER_BASE
    LDI t0, 8
    ADD t0, gp, t0
    LD t1, t0
    LDI t0, -8
    ADD t0, fp, t0
    ST t0, t1
    ; If statement
    ; Comparison: Variable(name=char, type=BYTE) EQ Literal(value=10, type=LONG)
    ; Variable access: char
    LDI t0, 16
    ADD t0, fp, t0
    LB t1, t0
    ; Literal value: 10
    LDI t0, 10
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_16, t2
    ; Variable declaration: row
    ; Arithmetic operation: DIV
    ; Variable access: console_cursor
    LDI t1, 16
    ADD t1, gp, t1
    LI t2, t1
    ; Variable access: SCREEN_WIDTH
    LDI t1, 0
    ADD t1, gp, t1
    LI t3, t1
    DIV t0, t2, t3
    LDI t1, -12
    ADD t1, fp, t1
    SI t1, t0
    ; If statement
    ; Comparison: Variable(name=row, type=INT) GE BinaryOp(op=SUB, left=Variable(name=SCREEN_HEIGHT, type=INT), right=Literal(value=1, type=LONG))
    ; Variable access: row
    LDI t0, -12
    ADD t0, fp, t0
    LI t1, t0
    ; Arithmetic operation: SUB
    ; Variable access: SCREEN_HEIGHT
    LDI t2, 4
    ADD t2, gp, t2
    LI t3, t2
    ; Literal value: 1
    LDI t2, 1
    SUB t0, t3, t2
    SUB t2, t1, t0
    ; Jump if t1 < t0
    JPN else_18, t2
    ; Expression statement
    ; Function call: console_scroll
    ; Preparing function call: console_scroll
    JAL console_scroll, ra
    MOV t0, a0
    ; Variable assignment: console_cursor
    ; Arithmetic operation: MUL
    ; Arithmetic operation: SUB
    ; Variable access: SCREEN_HEIGHT
    LDI t2, 4
    ADD t2, gp, t2
    LI t3, t2
    ; Literal value: 1
    LDI t2, 1
    SUB t1, t3, t2
    ; Variable access: SCREEN_WIDTH
    LDI t2, 0
    ADD t2, gp, t2
    LI t3, t2
    MUL t0, t1, t3
    LDI t1, 16
    ADD t1, gp, t1
    SI t1, t0
    JMP endif_19
else_18:
    ; Variable assignment: console_cursor
    ; Arithmetic operation: MUL
    ; Arithmetic operation: ADD
    ; Variable access: row
    LDI t2, -12
    ADD t2, fp, t2
    LI t3, t2
    ; Literal value: 1
    LDI t2, 1
    ADD t1, t3, t2
    ; Variable access: SCREEN_WIDTH
    LDI t2, 0
    ADD t2, gp, t2
    LI t3, t2
    MUL t0, t1, t3
    LDI t1, 16
    ADD t1, gp, t1
    SI t1, t0
endif_19:
    ; Return statement
    JMP console_putc_end_15
else_16:
    ; If statement
    ; Comparison: Variable(name=console_cursor, type=INT) GE BinaryOp(op=MUL, left=Variable(name=SCREEN_WIDTH, type=INT), right=Variable(name=SCREEN_HEIGHT, type=INT))
    ; Variable access: console_cursor
    LDI t0, 16
    ADD t0, gp, t0
    LI t1, t0
    ; Arithmetic operation: MUL
    ; Variable access: SCREEN_WIDTH
    LDI t2, 0
    ADD t2, gp, t2
    LI t3, t2
    ; Variable access: SCREEN_HEIGHT
    LDI t2, 4
    ADD t2, gp, t2
    LI t4, t2
    MUL t0, t3, t4
    SUB t2, t1, t0
    ; Jump if t1 < t0
    JPN else_20, t2
    ; Expression statement
    ; Function call: console_scroll
    ; Preparing function call: console_scroll
    JAL console_scroll, ra
    MOV t0, a0
    ; Variable assignment: console_cursor
    ; Arithmetic operation: MUL
    ; Arithmetic operation: SUB
    ; Variable access: SCREEN_HEIGHT
    LDI t2, 4
    ADD t2, gp, t2
    LI t3, t2
    ; Literal value: 1
    LDI t2, 1
    SUB t1, t3, t2
    ; Variable access: SCREEN_WIDTH
    LDI t2, 0
    ADD t2, gp, t2
    LI t3, t2
    MUL t0, t1, t3
    LDI t1, 16
    ADD t1, gp, t1
    SI t1, t0
else_20:
    ; Variable declaration: cell
    ; Type conversion to PointerType[elementType=StructType{name='ColorChar', complete=true}]
    ; Arithmetic operation: ADD
    ; Variable access: fb
    LDI t2, -8
    ADD t2, fp, t2
    LD t3, t2
    ; Arithmetic operation: MUL
    ; Variable access: console_cursor
    LDI t4, 16
    ADD t4, gp, t4
    LI t5, t4
    ; Literal value: 4
    LDI t4, 4
    MUL t2, t5, t4
    ADD t1, t3, t2
    ; Converting LONG to POINTER (no-op)
    MOV t0, t1
    LDI t1, -20
    ADD t1, fp, t1
    ST t1, t0
    ; Struct field assignment: ch
    ; Variable access: cell
    LDI t0, -20
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 0
    ADD t0, t1, t0
    ; Variable access: char
    LDI t2, 16
    ADD t2, fp, t2
    LB t3, t2
    SB t0, t3
    ; Struct field assignment: fg
    ; Variable access: cell
    LDI t0, -20
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 1
    ADD t0, t1, t0
    ; Literal value: 15
    LDI t2, 15
    SB t0, t2
    ; Struct field assignment: bg
    ; Variable access: cell
    LDI t0, -20
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 2
    ADD t0, t1, t0
    ; Literal value: 0
    LDI t2, 0
    SB t0, t2
    ; Struct field assignment: reserved
    ; Variable access: cell
    LDI t0, -20
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 3
    ADD t0, t1, t0
    ; Literal value: 0
    LDI t2, 0
    SB t0, t2
    ; Variable assignment: console_cursor
    ; Arithmetic operation: ADD
    ; Variable access: console_cursor
    LDI t1, 16
    ADD t1, gp, t1
    LI t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, 16
    ADD t1, gp, t1
    SI t1, t0
    ; Function epilogue
console_putc_end_15:
    LDI t0, 24
    ADD sp, sp, t0
    ; Deallocated 24 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ==============================
    ; Function: console_puts
    ; ==============================
console_puts:
    ; Pre-allocating 1 local variables
    ; Pre-allocated variable: i (INT)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 8 bytes
    LDI t0, 8
    SUB sp, sp, t0
    ; Allocated 8 bytes for stack frame
    ; Variable declaration: i
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -4
    ADD t1, fp, t1
    SI t1, t0
    ; While loop
loop_23:
    ; Comparison: Variable(name=i, type=INT) LT Variable(name=len, type=INT)
    ; Variable access: i
    LDI t0, -4
    ADD t0, fp, t0
    LI t1, t0
    ; Variable access: len
    LDI t0, 24
    ADD t0, fp, t0
    LI t2, t0
    SUB t0, t1, t2
    ; Jump if t1 >= t2
    JPN skip_ge_25, t0
    JMP endloop_24
skip_ge_25:
    ; Expression statement
    ; Function call: console_putc
    ; Preparing function call: console_putc
    ; Evaluating argument 0
    ; Dereference operation
    ; Arithmetic operation: ADD
    ; Variable access: str
    LDI t2, 16
    ADD t2, fp, t2
    LD t3, t2
    ; Variable access: i
    LDI t2, -4
    ADD t2, fp, t2
    LI t4, t2
    ADD t1, t3, t4
    LB t0, t1
    PUSH t0
    JAL console_putc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Variable assignment: i
    ; Arithmetic operation: ADD
    ; Variable access: i
    LDI t1, -4
    ADD t1, fp, t1
    LI t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -4
    ADD t1, fp, t1
    SI t1, t0
    JMP loop_23
endloop_24:
    ; Function epilogue
console_puts_end_22:
    LDI t0, 8
    ADD sp, sp, t0
    ; Deallocated 8 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; =====================================
    ; Function: print
    ; =====================================
print:
    ; Pre-allocating 0 local variables
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 0 bytes
    ; Expression statement
    ; Function call: console_puts
    ; Preparing function call: console_puts
    ; Evaluating argument 0
    ; Variable access: str
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: len
    LDI t0, 24
    ADD t0, fp, t0
    LI t2, t0
    PUSH t2
    PUSH t1
    JAL console_puts, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    ; Function epilogue
print_end_26:
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ===================================
    ; Function: println
    ; ===================================
println:
    ; Pre-allocating 0 local variables
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 0 bytes
    ; Expression statement
    ; Function call: print
    ; Preparing function call: print
    ; Evaluating argument 0
    ; Variable access: str
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: len
    LDI t0, 24
    ADD t0, fp, t0
    LI t2, t0
    PUSH t2
    PUSH t1
    JAL print, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: console_putc
    ; Preparing function call: console_putc
    ; Evaluating argument 0
    ; Literal value: 10
    LDI t0, 10
    PUSH t0
    JAL console_putc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Function epilogue
println_end_27:
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; =================================
    ; Function: print_raw
    ; =================================
print_raw:
    ; Pre-allocating 0 local variables
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 0 bytes
    ; Expression statement
    ; Function call: console_puts
    ; Preparing function call: console_puts
    ; Evaluating argument 0
    ; Variable access: ptr
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: len
    LDI t0, 24
    ADD t0, fp, t0
    LI t2, t0
    PUSH t2
    PUSH t1
    JAL console_puts, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    ; Function epilogue
print_raw_end_28:
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ==================================
    ; Function: align_up
    ; ==================================
align_up:
    ; Pre-allocating 0 local variables
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 0 bytes
    ; Return statement
    ; Arithmetic operation: SUB
    ; Arithmetic operation: ADD
    ; Variable access: size
    LDI t2, 16
    ADD t2, fp, t2
    LD t3, t2
    ; Variable access: alignment
    LDI t2, 24
    ADD t2, fp, t2
    LD t4, t2
    ADD t1, t3, t4
    ; Arithmetic operation: MOD
    ; Variable access: size
    LDI t3, 16
    ADD t3, fp, t3
    LD t4, t3
    ; Variable access: alignment
    LDI t3, 24
    ADD t3, fp, t3
    LD t5, t3
    MOD t2, t4, t5
    SUB t0, t1, t2
    MOV a0, t0
    JMP align_up_end_29
    ; Function epilogue
align_up_end_29:
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; =================================
    ; Function: init_heap
    ; =================================
init_heap:
    ; Pre-allocating 0 local variables
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 0 bytes
    ; If statement
    ; Comparison: Variable(name=freeListHead, type=PointerType[elementType=StructType{name='BlockHeader', complete=true}]) EQ Literal(value=0, type=LONG)
    ; Variable access: freeListHead
    LDI t0, 48
    ADD t0, gp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_31, t2
    ; Variable assignment: freeListHead
    ; Variable access: HEAP_START
    LDI t0, 20
    ADD t0, gp, t0
    LD t1, t0
    LDI t0, 48
    ADD t0, gp, t0
    ST t0, t1
    ; Struct field assignment: size
    ; Variable access: freeListHead
    LDI t0, 48
    ADD t0, gp, t0
    LD t1, t0
    LDI t0, 0
    ADD t0, t1, t0
    ; Variable access: HEAP_SIZE
    LDI t2, 28
    ADD t2, gp, t2
    LD t3, t2
    SI t0, t3
    ; Struct field assignment: next
    ; Variable access: freeListHead
    LDI t0, 48
    ADD t0, gp, t0
    LD t1, t0
    LDI t0, 4
    ADD t0, t1, t0
    ; Literal value: 0
    LDI t2, 0
    ST t0, t2
else_31:
    ; Function epilogue
init_heap_end_30:
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ==============================
    ; Function: unlink_block
    ; ==============================
unlink_block:
    ; Pre-allocating 0 local variables
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 0 bytes
    ; If statement
    ; Comparison: Variable(name=prev, type=PointerType[elementType=StructType{name='BlockHeader', complete=true}]) EQ Literal(value=0, type=LONG)
    ; Variable access: prev
    LDI t0, 24
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_34, t2
    ; Variable assignment: freeListHead
    ; Struct field access: next
    ; Variable access: block
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    LDI t2, 4
    ADD t2, t1, t2
    LD t0, t2
    LDI t1, 48
    ADD t1, gp, t1
    ST t1, t0
    JMP endif_35
else_34:
    ; Struct field assignment: next
    ; Variable access: prev
    LDI t0, 24
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 4
    ADD t0, t1, t0
    ; Struct field access: next
    ; Variable access: block
    LDI t2, 16
    ADD t2, fp, t2
    LD t3, t2
    LDI t4, 4
    ADD t4, t3, t4
    LD t2, t4
    ST t0, t2
endif_35:
    ; Function epilogue
unlink_block_end_33:
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ===============================
    ; Function: split_block
    ; ===============================
split_block:
    ; Pre-allocating 2 local variables
    ; Pre-allocated variable: remaining (LONG)
    ; Pre-allocated variable: new_block (PointerType[elementType=StructType{name='BlockHeader', complete=true}])
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 16 bytes
    LDI t0, 16
    SUB sp, sp, t0
    ; Allocated 16 bytes for stack frame
    ; Variable declaration: remaining
    ; Arithmetic operation: SUB
    ; Struct field access: size
    ; Variable access: block
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    LDI t3, 0
    ADD t3, t2, t3
    LI t1, t3
    ; Variable access: needed_size
    LDI t2, 24
    ADD t2, fp, t2
    LD t3, t2
    SUB t0, t1, t3
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; If statement
    ; Comparison: Variable(name=remaining, type=LONG) GE Variable(name=MIN_BLOCK_SIZE, type=INT)
    ; Variable access: remaining
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    ; Variable access: MIN_BLOCK_SIZE
    LDI t0, 40
    ADD t0, gp, t0
    LI t2, t0
    SUB t0, t1, t2
    ; Jump if t1 < t2
    JPN else_37, t0
    ; Variable declaration: new_block
    ; Type conversion to PointerType[elementType=StructType{name='BlockHeader', complete=true}]
    ; Arithmetic operation: ADD
    ; Variable access: block
    LDI t2, 16
    ADD t2, fp, t2
    LD t3, t2
    ; Variable access: needed_size
    LDI t2, 24
    ADD t2, fp, t2
    LD t4, t2
    ADD t1, t3, t4
    MOV t0, t1
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; Struct field assignment: size
    ; Variable access: new_block
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 0
    ADD t0, t1, t0
    ; Variable access: remaining
    LDI t2, -8
    ADD t2, fp, t2
    LD t3, t2
    SI t0, t3
    ; Struct field assignment: next
    ; Variable access: new_block
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 4
    ADD t0, t1, t0
    ; Variable access: freeListHead
    LDI t2, 48
    ADD t2, gp, t2
    LD t3, t2
    ST t0, t3
    ; Variable assignment: freeListHead
    ; Variable access: new_block
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 48
    ADD t0, gp, t0
    ST t0, t1
    ; Struct field assignment: size
    ; Variable access: block
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 0
    ADD t0, t1, t0
    ; Variable access: needed_size
    LDI t2, 24
    ADD t2, fp, t2
    LD t3, t2
    SI t0, t3
    ; Struct field assignment: next
    ; Variable access: block
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 4
    ADD t0, t1, t0
    ; Literal value: 0
    LDI t2, 0
    ST t0, t2
    JMP endif_38
else_37:
    ; Struct field assignment: next
    ; Variable access: block
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 4
    ADD t0, t1, t0
    ; Literal value: 0
    LDI t2, 0
    ST t0, t2
endif_38:
    ; Function epilogue
split_block_end_36:
    LDI t0, 16
    ADD sp, sp, t0
    ; Deallocated 16 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ====================================
    ; Function: malloc
    ; ====================================
malloc:
    ; Pre-allocating 3 local variables
    ; Pre-allocated variable: total_needed (LONG)
    ; Pre-allocated variable: current (PointerType[elementType=StructType{name='BlockHeader', complete=true}])
    ; Pre-allocated variable: prev (PointerType[elementType=StructType{name='BlockHeader', complete=true}])
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 24 bytes
    LDI t0, 24
    SUB sp, sp, t0
    ; Allocated 24 bytes for stack frame
    ; If statement
    ; Comparison: Variable(name=size_req, type=LONG) EQ Literal(value=0, type=LONG)
    ; Variable access: size_req
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_40, t2
    ; Return statement
    ; Literal value: 0
    LDI t0, 0
    MOV a0, t0
    JMP malloc_end_39
else_40:
    ; Expression statement
    ; Function call: init_heap
    ; Preparing function call: init_heap
    JAL init_heap, ra
    MOV t0, a0
    ; Variable declaration: total_needed
    ; Function call: align_up
    ; Preparing function call: align_up
    ; Evaluating argument 0
    ; Arithmetic operation: ADD
    ; Variable access: size_req
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: HEADER_SIZE
    LDI t1, 36
    ADD t1, gp, t1
    LI t3, t1
    ADD t0, t2, t3
    ; Evaluating argument 1
    ; Variable access: ALIGNMENT
    LDI t1, 44
    ADD t1, gp, t1
    LI t2, t1
    PUSH t2
    PUSH t0
    JAL align_up, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: current
    ; Variable access: freeListHead
    LDI t0, 48
    ADD t0, gp, t0
    LD t1, t0
    LDI t0, -16
    ADD t0, fp, t0
    ST t0, t1
    ; Variable declaration: prev
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    ; While loop
loop_42:
    ; Comparison: Variable(name=current, type=PointerType[elementType=StructType{name='BlockHeader', complete=true}]) NE Literal(value=0, type=LONG)
    ; Variable access: current
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 == t0
    JZ endloop_43, t2
    ; If statement
    ; Comparison: StructFieldAccess(base=Variable(name=current, type=PointerType[elementType=StructType{name='BlockHeader', complete=true}]), fieldName=size, fieldType=INT, fieldOffset=0) GE Variable(name=total_needed, type=LONG)
    ; Struct field access: size
    ; Variable access: current
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    LDI t2, 0
    ADD t2, t1, t2
    LI t0, t2
    ; Variable access: total_needed
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    SUB t1, t0, t2
    ; Jump if t0 < t2
    JPN else_44, t1
    ; Expression statement
    ; Function call: unlink_block
    ; Preparing function call: unlink_block
    ; Evaluating argument 0
    ; Variable access: current
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: prev
    LDI t0, -24
    ADD t0, fp, t0
    LD t2, t0
    PUSH t2
    PUSH t1
    JAL unlink_block, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: split_block
    ; Preparing function call: split_block
    ; Evaluating argument 0
    ; Variable access: current
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: total_needed
    LDI t0, -8
    ADD t0, fp, t0
    LD t2, t0
    PUSH t2
    PUSH t1
    JAL split_block, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    ; Return statement
    ; Arithmetic operation: ADD
    ; Type conversion to LONG
    ; Variable access: current
    LDI t2, -16
    ADD t2, fp, t2
    LD t3, t2
    MOV t1, t3
    ; Variable access: HEADER_SIZE
    LDI t2, 36
    ADD t2, gp, t2
    LI t3, t2
    ADD t0, t1, t3
    MOV a0, t0
    JMP malloc_end_39
else_44:
    ; Variable assignment: prev
    ; Variable access: current
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, -24
    ADD t0, fp, t0
    ST t0, t1
    ; Variable assignment: current
    ; Struct field access: next
    ; Variable access: current
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    LDI t2, 4
    ADD t2, t1, t2
    LD t0, t2
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    JMP loop_42
endloop_43:
    ; Return statement
    ; Literal value: 0
    LDI t0, 0
    MOV a0, t0
    JMP malloc_end_39
    ; Function epilogue
malloc_end_39:
    LDI t0, 24
    ADD sp, sp, t0
    ; Deallocated 24 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ======================================
    ; Function: free
    ; ======================================
free:
    ; Pre-allocating 1 local variables
    ; Pre-allocated variable: block (PointerType[elementType=StructType{name='BlockHeader', complete=true}])
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 8 bytes
    LDI t0, 8
    SUB sp, sp, t0
    ; Allocated 8 bytes for stack frame
    ; If statement
    ; Comparison: Variable(name=ptr, type=LONG) EQ Literal(value=0, type=LONG)
    ; Variable access: ptr
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_47, t2
    ; Return statement
    JMP free_end_46
else_47:
    ; Variable declaration: block
    ; Type conversion to PointerType[elementType=StructType{name='BlockHeader', complete=true}]
    ; Arithmetic operation: SUB
    ; Variable access: ptr
    LDI t2, 16
    ADD t2, fp, t2
    LD t3, t2
    ; Variable access: HEADER_SIZE
    LDI t2, 36
    ADD t2, gp, t2
    LI t4, t2
    SUB t1, t3, t4
    ; Converting LONG to POINTER (no-op)
    MOV t0, t1
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Struct field assignment: next
    ; Variable access: block
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 4
    ADD t0, t1, t0
    ; Variable access: freeListHead
    LDI t2, 48
    ADD t2, gp, t2
    LD t3, t2
    ST t0, t3
    ; Variable assignment: freeListHead
    ; Variable access: block
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 48
    ADD t0, gp, t0
    ST t0, t1
    ; Expression statement
    ; Function call: coalesce_free_blocks
    ; Preparing function call: coalesce_free_blocks
    JAL coalesce_free_blocks, ra
    MOV t0, a0
    ; Function epilogue
free_end_46:
    LDI t0, 8
    ADD sp, sp, t0
    ; Deallocated 8 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ===================================
    ; Function: realloc
    ; ===================================
realloc:
    ; Pre-allocating 6 local variables
    ; Pre-allocated variable: block (PointerType[elementType=StructType{name='BlockHeader', complete=true}])
    ; Pre-allocated variable: current_size (LONG)
    ; Pre-allocated variable: aligned_new_size (LONG)
    ; Pre-allocated variable: new_ptr (LONG)
    ; Pre-allocated variable: copy_size (LONG)
    ; Pre-allocated variable: i (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 48 bytes
    LDI t0, 48
    SUB sp, sp, t0
    ; Allocated 48 bytes for stack frame
    ; If statement
    ; Comparison: Variable(name=ptr, type=LONG) EQ Literal(value=0, type=LONG)
    ; Variable access: ptr
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_50, t2
    ; Return statement
    ; Function call: malloc
    ; Preparing function call: malloc
    ; Evaluating argument 0
    ; Variable access: new_size
    LDI t0, 24
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL malloc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    MOV a0, t0
    JMP realloc_end_49
else_50:
    ; If statement
    ; Comparison: Variable(name=new_size, type=LONG) EQ Literal(value=0, type=LONG)
    ; Variable access: new_size
    LDI t0, 24
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_52, t2
    ; Expression statement
    ; Function call: free
    ; Preparing function call: free
    ; Evaluating argument 0
    ; Variable access: ptr
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL free, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Return statement
    ; Literal value: 0
    LDI t0, 0
    MOV a0, t0
    JMP realloc_end_49
else_52:
    ; Variable declaration: block
    ; Type conversion to PointerType[elementType=StructType{name='BlockHeader', complete=true}]
    ; Arithmetic operation: SUB
    ; Variable access: ptr
    LDI t2, 16
    ADD t2, fp, t2
    LD t3, t2
    ; Variable access: HEADER_SIZE
    LDI t2, 36
    ADD t2, gp, t2
    LI t4, t2
    SUB t1, t3, t4
    ; Converting LONG to POINTER (no-op)
    MOV t0, t1
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: current_size
    ; Arithmetic operation: SUB
    ; Struct field access: size
    ; Variable access: block
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    LDI t3, 0
    ADD t3, t2, t3
    LI t1, t3
    ; Variable access: HEADER_SIZE
    LDI t2, 36
    ADD t2, gp, t2
    LI t3, t2
    SUB t0, t1, t3
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: aligned_new_size
    ; Function call: align_up
    ; Preparing function call: align_up
    ; Evaluating argument 0
    ; Variable access: new_size
    LDI t0, 24
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: ALIGNMENT
    LDI t0, 44
    ADD t0, gp, t0
    LI t2, t0
    PUSH t2
    PUSH t1
    JAL align_up, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    ; If statement
    ; Comparison: Variable(name=aligned_new_size, type=LONG) LE Variable(name=current_size, type=LONG)
    ; Variable access: aligned_new_size
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    ; Variable access: current_size
    LDI t0, -16
    ADD t0, fp, t0
    LD t2, t0
    SUB t0, t1, t2
    ; Jump if t1 > t2
    JPP else_54, t0
    ; Return statement
    ; Variable access: ptr
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    MOV a0, t1
    JMP realloc_end_49
else_54:
    ; Variable declaration: new_ptr
    ; Function call: malloc
    ; Preparing function call: malloc
    ; Evaluating argument 0
    ; Variable access: new_size
    LDI t0, 24
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL malloc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -32
    ADD t1, fp, t1
    ST t1, t0
    ; If statement
    ; Comparison: Variable(name=new_ptr, type=LONG) EQ Literal(value=0, type=LONG)
    ; Variable access: new_ptr
    LDI t0, -32
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_56, t2
    ; Return statement
    ; Literal value: 0
    LDI t0, 0
    MOV a0, t0
    JMP realloc_end_49
else_56:
    ; Variable declaration: copy_size
    ; Variable access: current_size
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, -40
    ADD t0, fp, t0
    ST t0, t1
    ; If statement
    ; Comparison: Variable(name=aligned_new_size, type=LONG) LT Variable(name=copy_size, type=LONG)
    ; Variable access: aligned_new_size
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    ; Variable access: copy_size
    LDI t0, -40
    ADD t0, fp, t0
    LD t2, t0
    SUB t0, t1, t2
    ; Jump if t1 >= t2
    JPN skip_ge_60, t0
    JMP else_58
skip_ge_60:
    ; Variable assignment: copy_size
    ; Variable access: aligned_new_size
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, -40
    ADD t0, fp, t0
    ST t0, t1
else_58:
    ; Variable declaration: i
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -48
    ADD t1, fp, t1
    ST t1, t0
    ; While loop
loop_61:
    ; Comparison: Variable(name=i, type=LONG) LT Variable(name=copy_size, type=LONG)
    ; Variable access: i
    LDI t0, -48
    ADD t0, fp, t0
    LD t1, t0
    ; Variable access: copy_size
    LDI t0, -40
    ADD t0, fp, t0
    LD t2, t0
    SUB t0, t1, t2
    ; Jump if t1 >= t2
    JPN skip_ge_63, t0
    JMP endloop_62
skip_ge_63:
    ; Arithmetic operation: ADD
    ; Variable access: new_ptr
    LDI t1, -32
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: i
    LDI t1, -48
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    ; Dereference assignment to address: t0
    ; Dereference operation
    ; Arithmetic operation: ADD
    ; Variable access: ptr
    LDI t3, 16
    ADD t3, fp, t3
    LD t4, t3
    ; Variable access: i
    LDI t3, -48
    ADD t3, fp, t3
    LD t5, t3
    ADD t2, t4, t5
    LB t1, t2
    ; Store BYTE to address t0
    SB t0, t1
    ; Variable assignment: i
    ; Arithmetic operation: ADD
    ; Variable access: i
    LDI t1, -48
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -48
    ADD t1, fp, t1
    ST t1, t0
    JMP loop_61
endloop_62:
    ; Expression statement
    ; Function call: free
    ; Preparing function call: free
    ; Evaluating argument 0
    ; Variable access: ptr
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL free, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Return statement
    ; Variable access: new_ptr
    LDI t0, -32
    ADD t0, fp, t0
    LD t1, t0
    MOV a0, t1
    JMP realloc_end_49
    ; Function epilogue
realloc_end_49:
    LDI t0, 48
    ADD sp, sp, t0
    ; Deallocated 48 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ====================================
    ; Function: calloc
    ; ====================================
calloc:
    ; Pre-allocating 3 local variables
    ; Pre-allocated variable: total_size (LONG)
    ; Pre-allocated variable: ptr (LONG)
    ; Pre-allocated variable: i (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 24 bytes
    LDI t0, 24
    SUB sp, sp, t0
    ; Allocated 24 bytes for stack frame
    ; Variable declaration: total_size
    ; Arithmetic operation: MUL
    ; Variable access: count
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: size
    LDI t1, 24
    ADD t1, fp, t1
    LD t3, t1
    MUL t0, t2, t3
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: ptr
    ; Function call: malloc
    ; Preparing function call: malloc
    ; Evaluating argument 0
    ; Variable access: total_size
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL malloc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; If statement
    ; Comparison: Variable(name=ptr, type=LONG) EQ Literal(value=0, type=LONG)
    ; Variable access: ptr
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_65, t2
    ; Return statement
    ; Literal value: 0
    LDI t0, 0
    MOV a0, t0
    JMP calloc_end_64
else_65:
    ; Variable declaration: i
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    ; While loop
loop_67:
    ; Comparison: Variable(name=i, type=LONG) LT Variable(name=total_size, type=LONG)
    ; Variable access: i
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    ; Variable access: total_size
    LDI t0, -8
    ADD t0, fp, t0
    LD t2, t0
    SUB t0, t1, t2
    ; Jump if t1 >= t2
    JPN skip_ge_69, t0
    JMP endloop_68
skip_ge_69:
    ; Arithmetic operation: ADD
    ; Variable access: ptr
    LDI t1, -16
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: i
    LDI t1, -24
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    ; Dereference assignment to address: t0
    ; Literal value: 0
    LDI t1, 0
    ; Store BYTE to address t0
    SB t0, t1
    ; Variable assignment: i
    ; Arithmetic operation: ADD
    ; Variable access: i
    LDI t1, -24
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    JMP loop_67
endloop_68:
    ; Return statement
    ; Variable access: ptr
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    MOV a0, t1
    JMP calloc_end_64
    ; Function epilogue
calloc_end_64:
    LDI t0, 24
    ADD sp, sp, t0
    ; Deallocated 24 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ======================
    ; Function: coalesce_free_blocks
    ; ======================
coalesce_free_blocks:
    ; Pre-allocating 2 local variables
    ; Pre-allocated variable: current (PointerType[elementType=StructType{name='BlockHeader', complete=true}])
    ; Pre-allocated variable: next (PointerType[elementType=StructType{name='BlockHeader', complete=true}])
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 16 bytes
    LDI t0, 16
    SUB sp, sp, t0
    ; Allocated 16 bytes for stack frame
    ; If statement
    ; Comparison: Variable(name=freeListHead, type=PointerType[elementType=StructType{name='BlockHeader', complete=true}]) EQ Literal(value=0, type=LONG)
    ; Variable access: freeListHead
    LDI t0, 48
    ADD t0, gp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_71, t2
    ; Return statement
    JMP coalesce_free_blocks_end_70
else_71:
    ; Variable declaration: current
    ; Variable access: freeListHead
    LDI t0, 48
    ADD t0, gp, t0
    LD t1, t0
    LDI t0, -8
    ADD t0, fp, t0
    ST t0, t1
    ; While loop
loop_73:
    ; Comparison: Variable(name=current, type=PointerType[elementType=StructType{name='BlockHeader', complete=true}]) NE Literal(value=0, type=LONG)
    ; Variable access: current
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 == t0
    JZ endloop_74, t2
    ; Variable declaration: next
    ; Struct field access: next
    ; Variable access: current
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    LDI t2, 4
    ADD t2, t1, t2
    LD t0, t2
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; If statement
    ; Logical AND: BinaryOp(op=NE, left=Variable(name=next, type=PointerType[elementType=StructType{name='BlockHeader', complete=true}]), right=Literal(value=0, type=LONG)) && BinaryOp(op=EQ, left=TypeConversion(expression=Variable(name=next, type=PointerType[elementType=StructType{name='BlockHeader', complete=true}]), targetType=LONG), right=BinaryOp(op=ADD, left=TypeConversion(expression=Variable(name=current, type=PointerType[elementType=StructType{name='BlockHeader', complete=true}]), targetType=LONG), right=StructFieldAccess(base=Variable(name=current, type=PointerType[elementType=StructType{name='BlockHeader', complete=true}]), fieldName=size, fieldType=INT, fieldOffset=0)))
    ; Comparison: Variable(name=next, type=PointerType[elementType=StructType{name='BlockHeader', complete=true}]) NE Literal(value=0, type=LONG)
    ; Variable access: next
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 == t0
    JZ else_75, t2
    ; Comparison: TypeConversion(expression=Variable(name=next, type=PointerType[elementType=StructType{name='BlockHeader', complete=true}]), targetType=LONG) EQ BinaryOp(op=ADD, left=TypeConversion(expression=Variable(name=current, type=PointerType[elementType=StructType{name='BlockHeader', complete=true}]), targetType=LONG), right=StructFieldAccess(base=Variable(name=current, type=PointerType[elementType=StructType{name='BlockHeader', complete=true}]), fieldName=size, fieldType=INT, fieldOffset=0))
    ; Type conversion to LONG
    ; Variable access: next
    LDI t1, -16
    ADD t1, fp, t1
    LD t2, t1
    MOV t0, t2
    ; Arithmetic operation: ADD
    ; Type conversion to LONG
    ; Variable access: current
    LDI t3, -8
    ADD t3, fp, t3
    LD t4, t3
    MOV t2, t4
    ; Struct field access: size
    ; Variable access: current
    LDI t3, -8
    ADD t3, fp, t3
    LD t4, t3
    LDI t5, 0
    ADD t5, t4, t5
    LI t3, t5
    ADD t1, t2, t3
    SUB t2, t0, t1
    ; Jump if t0 != t1
    JNZ else_75, t2
    ; Struct field assignment: size
    ; Variable access: current
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 0
    ADD t0, t1, t0
    ; Arithmetic operation: ADD
    ; Struct field access: size
    ; Variable access: current
    LDI t3, -8
    ADD t3, fp, t3
    LD t4, t3
    LDI t5, 0
    ADD t5, t4, t5
    LI t3, t5
    ; Struct field access: size
    ; Variable access: next
    LDI t4, -16
    ADD t4, fp, t4
    LD t5, t4
    LDI t6, 0
    ADD t6, t5, t6
    LI t4, t6
    ADD t2, t3, t4
    SI t0, t2
    ; Struct field assignment: next
    ; Variable access: current
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, 4
    ADD t0, t1, t0
    ; Struct field access: next
    ; Variable access: next
    LDI t2, -16
    ADD t2, fp, t2
    LD t3, t2
    LDI t4, 4
    ADD t4, t3, t4
    LD t2, t4
    ST t0, t2
    JMP endif_76
else_75:
    ; Variable assignment: current
    ; Variable access: next
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, -8
    ADD t0, fp, t0
    ST t0, t1
endif_76:
    JMP loop_73
endloop_74:
    ; Function epilogue
coalesce_free_blocks_end_70:
    LDI t0, 16
    ADD sp, sp, t0
    ; Deallocated 16 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ============================
    ; Function: get_last_digit
    ; ============================
get_last_digit:
    ; Pre-allocating 2 local variables
    ; Pre-allocated variable: tens (LONG)
    ; Pre-allocated variable: last_digit (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 16 bytes
    LDI t0, 16
    SUB sp, sp, t0
    ; Allocated 16 bytes for stack frame
    ; Variable declaration: tens
    ; Arithmetic operation: DIV
    ; Variable access: num
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 10
    LDI t1, 10
    DIV t0, t2, t1
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: last_digit
    ; Arithmetic operation: SUB
    ; Variable access: num
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    ; Arithmetic operation: MUL
    ; Variable access: tens
    LDI t3, -8
    ADD t3, fp, t3
    LD t4, t3
    ; Literal value: 10
    LDI t3, 10
    MUL t1, t4, t3
    SUB t0, t2, t1
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; Return statement
    ; Variable access: last_digit
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    MOV a0, t1
    JMP get_last_digit_end_77
    ; Function epilogue
get_last_digit_end_77:
    LDI t0, 16
    ADD sp, sp, t0
    ; Deallocated 16 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; =====================
    ; Function: get_digit_at_position
    ; =====================
get_digit_at_position:
    ; Pre-allocating 2 local variables
    ; Pre-allocated variable: temp (LONG)
    ; Pre-allocated variable: i (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 16 bytes
    LDI t0, 16
    SUB sp, sp, t0
    ; Allocated 16 bytes for stack frame
    ; Variable declaration: temp
    ; Variable access: num
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, -8
    ADD t0, fp, t0
    ST t0, t1
    ; Variable declaration: i
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; While loop
loop_79:
    ; Comparison: Variable(name=i, type=LONG) LT Variable(name=position, type=LONG)
    ; Variable access: i
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    ; Variable access: position
    LDI t0, 24
    ADD t0, fp, t0
    LD t2, t0
    SUB t0, t1, t2
    ; Jump if t1 >= t2
    JPN skip_ge_81, t0
    JMP endloop_80
skip_ge_81:
    ; Variable assignment: temp
    ; Arithmetic operation: DIV
    ; Variable access: temp
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 10
    LDI t1, 10
    DIV t0, t2, t1
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable assignment: i
    ; Arithmetic operation: ADD
    ; Variable access: i
    LDI t1, -16
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    JMP loop_79
endloop_80:
    ; Return statement
    ; Function call: get_last_digit
    ; Preparing function call: get_last_digit
    ; Evaluating argument 0
    ; Variable access: temp
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL get_last_digit, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    MOV a0, t0
    JMP get_digit_at_position_end_78
    ; Function epilogue
get_digit_at_position_end_78:
    LDI t0, 16
    ADD sp, sp, t0
    ; Deallocated 16 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; =========================
    ; Function: get_number_length
    ; =========================
get_number_length:
    ; Pre-allocating 2 local variables
    ; Pre-allocated variable: count (LONG)
    ; Pre-allocated variable: temp (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 16 bytes
    LDI t0, 16
    SUB sp, sp, t0
    ; Allocated 16 bytes for stack frame
    ; If statement
    ; Comparison: Variable(name=num, type=LONG) EQ Literal(value=0, type=LONG)
    ; Variable access: num
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_83, t2
    ; Return statement
    ; Literal value: 1
    LDI t0, 1
    MOV a0, t0
    JMP get_number_length_end_82
else_83:
    ; Variable declaration: count
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: temp
    ; Variable access: num
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    LDI t0, -16
    ADD t0, fp, t0
    ST t0, t1
    ; While loop
loop_85:
    ; Comparison: Variable(name=temp, type=LONG) GT Literal(value=0, type=LONG)
    ; Variable access: temp
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 <= t0
    JPP skip_le_87, t2
    JMP endloop_86
skip_le_87:
    ; Variable assignment: temp
    ; Arithmetic operation: DIV
    ; Variable access: temp
    LDI t1, -16
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 10
    LDI t1, 10
    DIV t0, t2, t1
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; Variable assignment: count
    ; Arithmetic operation: ADD
    ; Variable access: count
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    JMP loop_85
endloop_86:
    ; Return statement
    ; Variable access: count
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    MOV a0, t1
    JMP get_number_length_end_82
    ; Function epilogue
get_number_length_end_82:
    LDI t0, 16
    ADD sp, sp, t0
    ; Deallocated 16 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ==========================
    ; Function: number_to_string
    ; ==========================
number_to_string:
    ; Pre-allocating 4 local variables
    ; Pre-allocated variable: num_digits (LONG)
    ; Pre-allocated variable: digit_pos (LONG)
    ; Pre-allocated variable: string_pos (LONG)
    ; Pre-allocated variable: digit (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 32 bytes
    LDI t0, 32
    SUB sp, sp, t0
    ; Allocated 32 bytes for stack frame
    ; If statement
    ; Comparison: Variable(name=num, type=LONG) EQ Literal(value=0, type=LONG)
    ; Variable access: num
    LDI t0, 24
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 != t0
    JNZ else_89, t2
    ; Variable access: ptr
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    ; Dereference assignment to address: t1
    ; Literal value: 48
    LDI t0, 48
    ; Store LONG to address t1
    ST t1, t0
    ; Arithmetic operation: ADD
    ; Variable access: ptr
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 0
    LDI t1, 0
    ; Store LONG to address t0
    ST t0, t1
    ; Return statement
    ; Literal value: 1
    LDI t0, 1
    MOV a0, t0
    JMP number_to_string_end_88
else_89:
    ; Variable declaration: num_digits
    ; Function call: get_number_length
    ; Preparing function call: get_number_length
    ; Evaluating argument 0
    ; Variable access: num
    LDI t0, 24
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL get_number_length, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: digit_pos
    ; Arithmetic operation: SUB
    ; Variable access: num_digits
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    SUB t0, t2, t1
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: string_pos
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    ; While loop
loop_91:
    ; Comparison: Variable(name=digit_pos, type=LONG) GE Literal(value=0, type=LONG)
    ; Variable access: digit_pos
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 < t0
    JPN endloop_92, t2
    ; Variable declaration: digit
    ; Function call: get_digit_at_position
    ; Preparing function call: get_digit_at_position
    ; Evaluating argument 0
    ; Variable access: num
    LDI t0, 24
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: digit_pos
    LDI t0, -16
    ADD t0, fp, t0
    LD t2, t0
    PUSH t2
    PUSH t1
    JAL get_digit_at_position, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    LDI t1, -32
    ADD t1, fp, t1
    ST t1, t0
    ; Arithmetic operation: ADD
    ; Variable access: ptr
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: string_pos
    LDI t1, -24
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    ; Dereference assignment to address: t0
    ; Arithmetic operation: ADD
    ; Literal value: 48
    LDI t2, 48
    ; Variable access: digit
    LDI t3, -32
    ADD t3, fp, t3
    LD t4, t3
    ADD t1, t2, t4
    ; Store LONG to address t0
    ST t0, t1
    ; Variable assignment: string_pos
    ; Arithmetic operation: ADD
    ; Variable access: string_pos
    LDI t1, -24
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    ; Variable assignment: digit_pos
    ; Arithmetic operation: SUB
    ; Variable access: digit_pos
    LDI t1, -16
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    SUB t0, t2, t1
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    JMP loop_91
endloop_92:
    ; Arithmetic operation: ADD
    ; Variable access: ptr
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: string_pos
    LDI t1, -24
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    ; Dereference assignment to address: t0
    ; Literal value: 0
    LDI t1, 0
    ; Store LONG to address t0
    ST t0, t1
    ; Return statement
    ; Variable access: string_pos
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    MOV a0, t1
    JMP number_to_string_end_88
    ; Function epilogue
number_to_string_end_88:
    LDI t0, 32
    ADD sp, sp, t0
    ; Deallocated 32 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ================
    ; Function: create_message_with_number
    ; ================
create_message_with_number:
    ; Pre-allocating 4 local variables
    ; Pre-allocated variable: pos (LONG)
    ; Pre-allocated variable: prefix_pos (LONG)
    ; Pre-allocated variable: num_len (LONG)
    ; Pre-allocated variable: suffix_pos (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 32 bytes
    LDI t0, 32
    SUB sp, sp, t0
    ; Allocated 32 bytes for stack frame
    ; Variable declaration: pos
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: prefix_pos
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; While loop
loop_94:
    ; Comparison: Dereference(address=BinaryOp(op=ADD, left=Variable(name=prefix_text, type=LONG), right=Variable(name=prefix_pos, type=LONG)), type=LONG) NE Literal(value=0, type=LONG)
    ; Dereference operation
    ; Arithmetic operation: ADD
    ; Variable access: prefix_text
    LDI t2, 24
    ADD t2, fp, t2
    LD t3, t2
    ; Variable access: prefix_pos
    LDI t2, -16
    ADD t2, fp, t2
    LD t4, t2
    ADD t1, t3, t4
    LD t0, t1
    ; Literal value: 0
    LDI t1, 0
    SUB t2, t0, t1
    ; Jump if t0 == t1
    JZ endloop_95, t2
    ; Arithmetic operation: ADD
    ; Variable access: ptr
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: pos
    LDI t1, -8
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    ; Dereference assignment to address: t0
    ; Dereference operation
    ; Arithmetic operation: ADD
    ; Variable access: prefix_text
    LDI t3, 24
    ADD t3, fp, t3
    LD t4, t3
    ; Variable access: prefix_pos
    LDI t3, -16
    ADD t3, fp, t3
    LD t5, t3
    ADD t2, t4, t5
    LD t1, t2
    ; Store LONG to address t0
    ST t0, t1
    ; Variable assignment: pos
    ; Arithmetic operation: ADD
    ; Variable access: pos
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable assignment: prefix_pos
    ; Arithmetic operation: ADD
    ; Variable access: prefix_pos
    LDI t1, -16
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    JMP loop_94
endloop_95:
    ; Variable declaration: num_len
    ; Function call: number_to_string
    ; Preparing function call: number_to_string
    ; Evaluating argument 0
    ; Arithmetic operation: ADD
    ; Variable access: ptr
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: pos
    LDI t1, -8
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    ; Evaluating argument 1
    ; Variable access: num
    LDI t1, 32
    ADD t1, fp, t1
    LD t2, t1
    PUSH t2
    PUSH t0
    JAL number_to_string, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    ; Variable assignment: pos
    ; Arithmetic operation: ADD
    ; Variable access: pos
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: num_len
    LDI t1, -24
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: suffix_pos
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -32
    ADD t1, fp, t1
    ST t1, t0
    ; While loop
loop_96:
    ; Comparison: Dereference(address=BinaryOp(op=ADD, left=Variable(name=suffix_text, type=LONG), right=Variable(name=suffix_pos, type=LONG)), type=LONG) NE Literal(value=0, type=LONG)
    ; Dereference operation
    ; Arithmetic operation: ADD
    ; Variable access: suffix_text
    LDI t2, 40
    ADD t2, fp, t2
    LD t3, t2
    ; Variable access: suffix_pos
    LDI t2, -32
    ADD t2, fp, t2
    LD t4, t2
    ADD t1, t3, t4
    LD t0, t1
    ; Literal value: 0
    LDI t1, 0
    SUB t2, t0, t1
    ; Jump if t0 == t1
    JZ endloop_97, t2
    ; Arithmetic operation: ADD
    ; Variable access: ptr
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: pos
    LDI t1, -8
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    ; Dereference assignment to address: t0
    ; Dereference operation
    ; Arithmetic operation: ADD
    ; Variable access: suffix_text
    LDI t3, 40
    ADD t3, fp, t3
    LD t4, t3
    ; Variable access: suffix_pos
    LDI t3, -32
    ADD t3, fp, t3
    LD t5, t3
    ADD t2, t4, t5
    LD t1, t2
    ; Store LONG to address t0
    ST t0, t1
    ; Variable assignment: pos
    ; Arithmetic operation: ADD
    ; Variable access: pos
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable assignment: suffix_pos
    ; Arithmetic operation: ADD
    ; Variable access: suffix_pos
    LDI t1, -32
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -32
    ADD t1, fp, t1
    ST t1, t0
    JMP loop_96
endloop_97:
    ; Arithmetic operation: ADD
    ; Variable access: ptr
    LDI t1, 16
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: pos
    LDI t1, -8
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    ; Dereference assignment to address: t0
    ; Literal value: 0
    LDI t1, 0
    ; Store LONG to address t0
    ST t0, t1
    ; Return statement
    ; Variable access: pos
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    MOV a0, t1
    JMP create_message_with_number_end_93
    ; Function epilogue
create_message_with_number_end_93:
    LDI t0, 32
    ADD sp, sp, t0
    ; Deallocated 32 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ==============================
    ; Function: print_number
    ; ==============================
print_number:
    ; Pre-allocating 2 local variables
    ; Pre-allocated variable: buffer (LONG)
    ; Pre-allocated variable: len (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 16 bytes
    LDI t0, 16
    SUB sp, sp, t0
    ; Allocated 16 bytes for stack frame
    ; Variable declaration: buffer
    ; Function call: malloc
    ; Preparing function call: malloc
    ; Evaluating argument 0
    ; Literal value: 20
    LDI t0, 20
    PUSH t0
    JAL malloc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: len
    ; Function call: number_to_string
    ; Preparing function call: number_to_string
    ; Evaluating argument 0
    ; Variable access: buffer
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: num
    LDI t0, 16
    ADD t0, fp, t0
    LD t2, t0
    PUSH t2
    PUSH t1
    JAL number_to_string, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; Expression statement
    ; Function call: print
    ; Preparing function call: print
    ; Evaluating argument 0
    ; Variable access: buffer
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: len
    LDI t0, -16
    ADD t0, fp, t0
    LD t2, t0
    PUSH t2
    PUSH t1
    JAL print, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: free
    ; Preparing function call: free
    ; Evaluating argument 0
    ; Variable access: buffer
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL free, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Function epilogue
print_number_end_98:
    LDI t0, 16
    ADD sp, sp, t0
    ; Deallocated 16 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; =================
    ; Function: print_number_with_newline
    ; =================
print_number_with_newline:
    ; Pre-allocating 0 local variables
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 0 bytes
    ; Expression statement
    ; Function call: print_number
    ; Preparing function call: print_number
    ; Evaluating argument 0
    ; Variable access: num
    LDI t0, 16
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL print_number, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: console_putc
    ; Preparing function call: console_putc
    ; Evaluating argument 0
    ; Literal value: 10
    LDI t0, 10
    PUSH t0
    JAL console_putc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Function epilogue
print_number_with_newline_end_99:
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ========================
    ; Function: demo_basic_numbers
    ; ========================
demo_basic_numbers:
    ; Pre-allocating 0 local variables
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 0 bytes
    ; Expression statement
    ; Function call: print_number_with_newline
    ; Preparing function call: print_number_with_newline
    ; Evaluating argument 0
    ; Literal value: 0
    LDI t0, 0
    PUSH t0
    JAL print_number_with_newline, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: print_number_with_newline
    ; Preparing function call: print_number_with_newline
    ; Evaluating argument 0
    ; Literal value: 5
    LDI t0, 5
    PUSH t0
    JAL print_number_with_newline, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: print_number_with_newline
    ; Preparing function call: print_number_with_newline
    ; Evaluating argument 0
    ; Literal value: 42
    LDI t0, 42
    PUSH t0
    JAL print_number_with_newline, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: print_number_with_newline
    ; Preparing function call: print_number_with_newline
    ; Evaluating argument 0
    ; Literal value: 123
    LDI t0, 123
    PUSH t0
    JAL print_number_with_newline, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: print_number_with_newline
    ; Preparing function call: print_number_with_newline
    ; Evaluating argument 0
    ; Literal value: 999
    LDI t0, 999
    PUSH t0
    JAL print_number_with_newline, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: print_number_with_newline
    ; Preparing function call: print_number_with_newline
    ; Evaluating argument 0
    ; Literal value: 1000
    LDI t0, 1000
    PUSH t0
    JAL print_number_with_newline, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: print_number_with_newline
    ; Preparing function call: print_number_with_newline
    ; Evaluating argument 0
    ; Literal value: 12345
    LDI t0, 12345
    PUSH t0
    JAL print_number_with_newline, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: print_number_with_newline
    ; Preparing function call: print_number_with_newline
    ; Evaluating argument 0
    ; Literal value: 99999
    LDI t0, 99999
    PUSH t0
    JAL print_number_with_newline, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Function epilogue
demo_basic_numbers_end_100:
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ===================
    ; Function: demo_formatted_messages
    ; ===================
demo_formatted_messages:
    ; Pre-allocating 5 local variables
    ; Pre-allocated variable: message_buffer (LONG)
    ; Pre-allocated variable: prefix (LONG)
    ; Pre-allocated variable: suffix (LONG)
    ; Pre-allocated variable: count (LONG)
    ; Pre-allocated variable: msg_len (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 40 bytes
    LDI t0, 40
    SUB sp, sp, t0
    ; Allocated 40 bytes for stack frame
    ; Variable declaration: message_buffer
    ; Function call: malloc
    ; Preparing function call: malloc
    ; Evaluating argument 0
    ; Literal value: 100
    LDI t0, 100
    PUSH t0
    JAL malloc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: prefix
    ; Function call: malloc
    ; Preparing function call: malloc
    ; Evaluating argument 0
    ; Literal value: 20
    LDI t0, 20
    PUSH t0
    JAL malloc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: suffix
    ; Function call: malloc
    ; Preparing function call: malloc
    ; Evaluating argument 0
    ; Literal value: 20
    LDI t0, 20
    PUSH t0
    JAL malloc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    ; Variable access: prefix
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    ; Dereference assignment to address: t1
    ; Literal value: 67
    LDI t0, 67
    ; Store LONG to address t1
    ST t1, t0
    ; Arithmetic operation: ADD
    ; Variable access: prefix
    LDI t1, -16
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 111
    LDI t1, 111
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: prefix
    LDI t1, -16
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 2
    LDI t1, 2
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 117
    LDI t1, 117
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: prefix
    LDI t1, -16
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 3
    LDI t1, 3
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 110
    LDI t1, 110
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: prefix
    LDI t1, -16
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 4
    LDI t1, 4
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 116
    LDI t1, 116
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: prefix
    LDI t1, -16
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 5
    LDI t1, 5
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 58
    LDI t1, 58
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: prefix
    LDI t1, -16
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 6
    LDI t1, 6
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 32
    LDI t1, 32
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: prefix
    LDI t1, -16
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 7
    LDI t1, 7
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 0
    LDI t1, 0
    ; Store LONG to address t0
    ST t0, t1
    ; Variable access: suffix
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    ; Dereference assignment to address: t1
    ; Literal value: 32
    LDI t0, 32
    ; Store LONG to address t1
    ST t1, t0
    ; Arithmetic operation: ADD
    ; Variable access: suffix
    LDI t1, -24
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 105
    LDI t1, 105
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: suffix
    LDI t1, -24
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 2
    LDI t1, 2
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 116
    LDI t1, 116
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: suffix
    LDI t1, -24
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 3
    LDI t1, 3
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 101
    LDI t1, 101
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: suffix
    LDI t1, -24
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 4
    LDI t1, 4
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 109
    LDI t1, 109
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: suffix
    LDI t1, -24
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 5
    LDI t1, 5
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 115
    LDI t1, 115
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: suffix
    LDI t1, -24
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 6
    LDI t1, 6
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 0
    LDI t1, 0
    ; Store LONG to address t0
    ST t0, t1
    ; Variable declaration: count
    ; Literal value: 1
    LDI t0, 1
    LDI t1, -32
    ADD t1, fp, t1
    ST t1, t0
    ; While loop
loop_102:
    ; Comparison: Variable(name=count, type=LONG) LE Literal(value=10, type=LONG)
    ; Variable access: count
    LDI t0, -32
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 10
    LDI t0, 10
    SUB t2, t1, t0
    ; Jump if t1 > t0
    JPP endloop_103, t2
    ; Variable declaration: msg_len
    ; Function call: create_message_with_number
    ; Preparing function call: create_message_with_number
    ; Evaluating argument 0
    ; Variable access: message_buffer
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: prefix
    LDI t0, -16
    ADD t0, fp, t0
    LD t2, t0
    ; Evaluating argument 2
    ; Variable access: count
    LDI t0, -32
    ADD t0, fp, t0
    LD t3, t0
    ; Evaluating argument 3
    ; Variable access: suffix
    LDI t0, -24
    ADD t0, fp, t0
    LD t4, t0
    PUSH t4
    PUSH t3
    PUSH t2
    PUSH t1
    JAL create_message_with_number, ra
    LDI t0, 32
    ADD sp, sp, t0
    ; Cleaned up 4 arguments from stack
    MOV t0, a0
    LDI t1, -40
    ADD t1, fp, t1
    ST t1, t0
    ; Expression statement
    ; Function call: print
    ; Preparing function call: print
    ; Evaluating argument 0
    ; Variable access: message_buffer
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: msg_len
    LDI t0, -40
    ADD t0, fp, t0
    LD t2, t0
    PUSH t2
    PUSH t1
    JAL print, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: console_putc
    ; Preparing function call: console_putc
    ; Evaluating argument 0
    ; Literal value: 10
    LDI t0, 10
    PUSH t0
    JAL console_putc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Variable assignment: count
    ; Arithmetic operation: ADD
    ; Variable access: count
    LDI t1, -32
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -32
    ADD t1, fp, t1
    ST t1, t0
    JMP loop_102
endloop_103:
    ; Expression statement
    ; Function call: free
    ; Preparing function call: free
    ; Evaluating argument 0
    ; Variable access: message_buffer
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL free, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: free
    ; Preparing function call: free
    ; Evaluating argument 0
    ; Variable access: prefix
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL free, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: free
    ; Preparing function call: free
    ; Evaluating argument 0
    ; Variable access: suffix
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL free, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Function epilogue
demo_formatted_messages_end_101:
    LDI t0, 40
    ADD sp, sp, t0
    ; Deallocated 40 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ===========================
    ; Function: demo_math_table
    ; ===========================
demo_math_table:
    ; Pre-allocating 12 local variables
    ; Pre-allocated variable: line_buffer (LONG)
    ; Pre-allocated variable: times_text (LONG)
    ; Pre-allocated variable: equals_text (LONG)
    ; Pre-allocated variable: a (LONG)
    ; Pre-allocated variable: b (LONG)
    ; Pre-allocated variable: result (LONG)
    ; Pre-allocated variable: pos (LONG)
    ; Pre-allocated variable: len1 (LONG)
    ; Pre-allocated variable: times_pos (LONG)
    ; Pre-allocated variable: len2 (LONG)
    ; Pre-allocated variable: equals_pos (LONG)
    ; Pre-allocated variable: len3 (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 96 bytes
    LDI t0, 96
    SUB sp, sp, t0
    ; Allocated 96 bytes for stack frame
    ; Variable declaration: line_buffer
    ; Function call: malloc
    ; Preparing function call: malloc
    ; Evaluating argument 0
    ; Literal value: 50
    LDI t0, 50
    PUSH t0
    JAL malloc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: times_text
    ; Function call: malloc
    ; Preparing function call: malloc
    ; Evaluating argument 0
    ; Literal value: 10
    LDI t0, 10
    PUSH t0
    JAL malloc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: equals_text
    ; Function call: malloc
    ; Preparing function call: malloc
    ; Evaluating argument 0
    ; Literal value: 10
    LDI t0, 10
    PUSH t0
    JAL malloc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    ; Variable access: times_text
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    ; Dereference assignment to address: t1
    ; Literal value: 32
    LDI t0, 32
    ; Store LONG to address t1
    ST t1, t0
    ; Arithmetic operation: ADD
    ; Variable access: times_text
    LDI t1, -16
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 120
    LDI t1, 120
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: times_text
    LDI t1, -16
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 2
    LDI t1, 2
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 32
    LDI t1, 32
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: times_text
    LDI t1, -16
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 3
    LDI t1, 3
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 0
    LDI t1, 0
    ; Store LONG to address t0
    ST t0, t1
    ; Variable access: equals_text
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    ; Dereference assignment to address: t1
    ; Literal value: 32
    LDI t0, 32
    ; Store LONG to address t1
    ST t1, t0
    ; Arithmetic operation: ADD
    ; Variable access: equals_text
    LDI t1, -24
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 61
    LDI t1, 61
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: equals_text
    LDI t1, -24
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 2
    LDI t1, 2
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 32
    LDI t1, 32
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: equals_text
    LDI t1, -24
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 3
    LDI t1, 3
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 0
    LDI t1, 0
    ; Store LONG to address t0
    ST t0, t1
    ; Variable declaration: a
    ; Literal value: 1
    LDI t0, 1
    LDI t1, -32
    ADD t1, fp, t1
    ST t1, t0
    ; While loop
loop_105:
    ; Comparison: Variable(name=a, type=LONG) LE Literal(value=5, type=LONG)
    ; Variable access: a
    LDI t0, -32
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 5
    LDI t0, 5
    SUB t2, t1, t0
    ; Jump if t1 > t0
    JPP endloop_106, t2
    ; Variable declaration: b
    ; Literal value: 1
    LDI t0, 1
    LDI t1, -40
    ADD t1, fp, t1
    ST t1, t0
    ; While loop
loop_107:
    ; Comparison: Variable(name=b, type=LONG) LE Literal(value=5, type=LONG)
    ; Variable access: b
    LDI t0, -40
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 5
    LDI t0, 5
    SUB t2, t1, t0
    ; Jump if t1 > t0
    JPP endloop_108, t2
    ; Variable declaration: result
    ; Arithmetic operation: MUL
    ; Variable access: a
    LDI t1, -32
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: b
    LDI t1, -40
    ADD t1, fp, t1
    LD t3, t1
    MUL t0, t2, t3
    LDI t1, -48
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: pos
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -56
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: len1
    ; Function call: number_to_string
    ; Preparing function call: number_to_string
    ; Evaluating argument 0
    ; Arithmetic operation: ADD
    ; Variable access: line_buffer
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: pos
    LDI t1, -56
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    ; Evaluating argument 1
    ; Variable access: a
    LDI t1, -32
    ADD t1, fp, t1
    LD t2, t1
    PUSH t2
    PUSH t0
    JAL number_to_string, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    LDI t1, -64
    ADD t1, fp, t1
    ST t1, t0
    ; Variable assignment: pos
    ; Arithmetic operation: ADD
    ; Variable access: pos
    LDI t1, -56
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: len1
    LDI t1, -64
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    LDI t1, -56
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: times_pos
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -72
    ADD t1, fp, t1
    ST t1, t0
    ; While loop
loop_109:
    ; Comparison: Dereference(address=BinaryOp(op=ADD, left=Variable(name=times_text, type=LONG), right=Variable(name=times_pos, type=LONG)), type=LONG) NE Literal(value=0, type=LONG)
    ; Dereference operation
    ; Arithmetic operation: ADD
    ; Variable access: times_text
    LDI t2, -16
    ADD t2, fp, t2
    LD t3, t2
    ; Variable access: times_pos
    LDI t2, -72
    ADD t2, fp, t2
    LD t4, t2
    ADD t1, t3, t4
    LD t0, t1
    ; Literal value: 0
    LDI t1, 0
    SUB t2, t0, t1
    ; Jump if t0 == t1
    JZ endloop_110, t2
    ; Arithmetic operation: ADD
    ; Variable access: line_buffer
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: pos
    LDI t1, -56
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    ; Dereference assignment to address: t0
    ; Dereference operation
    ; Arithmetic operation: ADD
    ; Variable access: times_text
    LDI t3, -16
    ADD t3, fp, t3
    LD t4, t3
    ; Variable access: times_pos
    LDI t3, -72
    ADD t3, fp, t3
    LD t5, t3
    ADD t2, t4, t5
    LD t1, t2
    ; Store LONG to address t0
    ST t0, t1
    ; Variable assignment: pos
    ; Arithmetic operation: ADD
    ; Variable access: pos
    LDI t1, -56
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -56
    ADD t1, fp, t1
    ST t1, t0
    ; Variable assignment: times_pos
    ; Arithmetic operation: ADD
    ; Variable access: times_pos
    LDI t1, -72
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -72
    ADD t1, fp, t1
    ST t1, t0
    JMP loop_109
endloop_110:
    ; Variable declaration: len2
    ; Function call: number_to_string
    ; Preparing function call: number_to_string
    ; Evaluating argument 0
    ; Arithmetic operation: ADD
    ; Variable access: line_buffer
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: pos
    LDI t1, -56
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    ; Evaluating argument 1
    ; Variable access: b
    LDI t1, -40
    ADD t1, fp, t1
    LD t2, t1
    PUSH t2
    PUSH t0
    JAL number_to_string, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    LDI t1, -80
    ADD t1, fp, t1
    ST t1, t0
    ; Variable assignment: pos
    ; Arithmetic operation: ADD
    ; Variable access: pos
    LDI t1, -56
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: len2
    LDI t1, -80
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    LDI t1, -56
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: equals_pos
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -88
    ADD t1, fp, t1
    ST t1, t0
    ; While loop
loop_111:
    ; Comparison: Dereference(address=BinaryOp(op=ADD, left=Variable(name=equals_text, type=LONG), right=Variable(name=equals_pos, type=LONG)), type=LONG) NE Literal(value=0, type=LONG)
    ; Dereference operation
    ; Arithmetic operation: ADD
    ; Variable access: equals_text
    LDI t2, -24
    ADD t2, fp, t2
    LD t3, t2
    ; Variable access: equals_pos
    LDI t2, -88
    ADD t2, fp, t2
    LD t4, t2
    ADD t1, t3, t4
    LD t0, t1
    ; Literal value: 0
    LDI t1, 0
    SUB t2, t0, t1
    ; Jump if t0 == t1
    JZ endloop_112, t2
    ; Arithmetic operation: ADD
    ; Variable access: line_buffer
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: pos
    LDI t1, -56
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    ; Dereference assignment to address: t0
    ; Dereference operation
    ; Arithmetic operation: ADD
    ; Variable access: equals_text
    LDI t3, -24
    ADD t3, fp, t3
    LD t4, t3
    ; Variable access: equals_pos
    LDI t3, -88
    ADD t3, fp, t3
    LD t5, t3
    ADD t2, t4, t5
    LD t1, t2
    ; Store LONG to address t0
    ST t0, t1
    ; Variable assignment: pos
    ; Arithmetic operation: ADD
    ; Variable access: pos
    LDI t1, -56
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -56
    ADD t1, fp, t1
    ST t1, t0
    ; Variable assignment: equals_pos
    ; Arithmetic operation: ADD
    ; Variable access: equals_pos
    LDI t1, -88
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -88
    ADD t1, fp, t1
    ST t1, t0
    JMP loop_111
endloop_112:
    ; Variable declaration: len3
    ; Function call: number_to_string
    ; Preparing function call: number_to_string
    ; Evaluating argument 0
    ; Arithmetic operation: ADD
    ; Variable access: line_buffer
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: pos
    LDI t1, -56
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    ; Evaluating argument 1
    ; Variable access: result
    LDI t1, -48
    ADD t1, fp, t1
    LD t2, t1
    PUSH t2
    PUSH t0
    JAL number_to_string, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    LDI t1, -96
    ADD t1, fp, t1
    ST t1, t0
    ; Variable assignment: pos
    ; Arithmetic operation: ADD
    ; Variable access: pos
    LDI t1, -56
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: len3
    LDI t1, -96
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    LDI t1, -56
    ADD t1, fp, t1
    ST t1, t0
    ; Arithmetic operation: ADD
    ; Variable access: line_buffer
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Variable access: pos
    LDI t1, -56
    ADD t1, fp, t1
    LD t3, t1
    ADD t0, t2, t3
    ; Dereference assignment to address: t0
    ; Literal value: 0
    LDI t1, 0
    ; Store LONG to address t0
    ST t0, t1
    ; Expression statement
    ; Function call: print
    ; Preparing function call: print
    ; Evaluating argument 0
    ; Variable access: line_buffer
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: pos
    LDI t0, -56
    ADD t0, fp, t0
    LD t2, t0
    PUSH t2
    PUSH t1
    JAL print, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: console_putc
    ; Preparing function call: console_putc
    ; Evaluating argument 0
    ; Literal value: 10
    LDI t0, 10
    PUSH t0
    JAL console_putc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Variable assignment: b
    ; Arithmetic operation: ADD
    ; Variable access: b
    LDI t1, -40
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -40
    ADD t1, fp, t1
    ST t1, t0
    JMP loop_107
endloop_108:
    ; Variable assignment: a
    ; Arithmetic operation: ADD
    ; Variable access: a
    LDI t1, -32
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -32
    ADD t1, fp, t1
    ST t1, t0
    JMP loop_105
endloop_106:
    ; Expression statement
    ; Function call: free
    ; Preparing function call: free
    ; Evaluating argument 0
    ; Variable access: line_buffer
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL free, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: free
    ; Preparing function call: free
    ; Evaluating argument 0
    ; Variable access: times_text
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL free, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: free
    ; Preparing function call: free
    ; Evaluating argument 0
    ; Variable access: equals_text
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL free, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Function epilogue
demo_math_table_end_104:
    LDI t0, 96
    ADD sp, sp, t0
    ; Deallocated 96 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ============================
    ; Function: demo_countdown
    ; ============================
demo_countdown:
    ; Pre-allocating 6 local variables
    ; Pre-allocated variable: prefix (LONG)
    ; Pre-allocated variable: empty_suffix (LONG)
    ; Pre-allocated variable: countdown (LONG)
    ; Pre-allocated variable: message (LONG)
    ; Pre-allocated variable: len (LONG)
    ; Pre-allocated variable: delay (LONG)
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 48 bytes
    LDI t0, 48
    SUB sp, sp, t0
    ; Allocated 48 bytes for stack frame
    ; Variable declaration: prefix
    ; Function call: malloc
    ; Preparing function call: malloc
    ; Evaluating argument 0
    ; Literal value: 15
    LDI t0, 15
    PUSH t0
    JAL malloc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -8
    ADD t1, fp, t1
    ST t1, t0
    ; Variable access: prefix
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    ; Dereference assignment to address: t1
    ; Literal value: 67
    LDI t0, 67
    ; Store LONG to address t1
    ST t1, t0
    ; Arithmetic operation: ADD
    ; Variable access: prefix
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 111
    LDI t1, 111
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: prefix
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 2
    LDI t1, 2
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 117
    LDI t1, 117
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: prefix
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 3
    LDI t1, 3
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 110
    LDI t1, 110
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: prefix
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 4
    LDI t1, 4
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 116
    LDI t1, 116
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: prefix
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 5
    LDI t1, 5
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 100
    LDI t1, 100
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: prefix
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 6
    LDI t1, 6
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 111
    LDI t1, 111
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: prefix
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 7
    LDI t1, 7
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 119
    LDI t1, 119
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: prefix
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 8
    LDI t1, 8
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 110
    LDI t1, 110
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: prefix
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 9
    LDI t1, 9
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 58
    LDI t1, 58
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: prefix
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 10
    LDI t1, 10
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 32
    LDI t1, 32
    ; Store LONG to address t0
    ST t0, t1
    ; Arithmetic operation: ADD
    ; Variable access: prefix
    LDI t1, -8
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 11
    LDI t1, 11
    ADD t0, t2, t1
    ; Dereference assignment to address: t0
    ; Literal value: 0
    LDI t1, 0
    ; Store LONG to address t0
    ST t0, t1
    ; Variable declaration: empty_suffix
    ; Function call: malloc
    ; Preparing function call: malloc
    ; Evaluating argument 0
    ; Literal value: 5
    LDI t0, 5
    PUSH t0
    JAL malloc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -16
    ADD t1, fp, t1
    ST t1, t0
    ; Variable access: empty_suffix
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    ; Dereference assignment to address: t1
    ; Literal value: 0
    LDI t0, 0
    ; Store LONG to address t1
    ST t1, t0
    ; Variable declaration: countdown
    ; Literal value: 50
    LDI t0, 50
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    ; While loop
loop_114:
    ; Comparison: Variable(name=countdown, type=LONG) GE Literal(value=0, type=LONG)
    ; Variable access: countdown
    LDI t0, -24
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 0
    LDI t0, 0
    SUB t2, t1, t0
    ; Jump if t1 < t0
    JPN endloop_115, t2
    ; Variable declaration: message
    ; Function call: malloc
    ; Preparing function call: malloc
    ; Evaluating argument 0
    ; Literal value: 30
    LDI t0, 30
    PUSH t0
    JAL malloc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    LDI t1, -32
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: len
    ; Function call: create_message_with_number
    ; Preparing function call: create_message_with_number
    ; Evaluating argument 0
    ; Variable access: message
    LDI t0, -32
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: prefix
    LDI t0, -8
    ADD t0, fp, t0
    LD t2, t0
    ; Evaluating argument 2
    ; Variable access: countdown
    LDI t0, -24
    ADD t0, fp, t0
    LD t3, t0
    ; Evaluating argument 3
    ; Variable access: empty_suffix
    LDI t0, -16
    ADD t0, fp, t0
    LD t4, t0
    PUSH t4
    PUSH t3
    PUSH t2
    PUSH t1
    JAL create_message_with_number, ra
    LDI t0, 32
    ADD sp, sp, t0
    ; Cleaned up 4 arguments from stack
    MOV t0, a0
    LDI t1, -40
    ADD t1, fp, t1
    ST t1, t0
    ; Expression statement
    ; Function call: print
    ; Preparing function call: print
    ; Evaluating argument 0
    ; Variable access: message
    LDI t0, -32
    ADD t0, fp, t0
    LD t1, t0
    ; Evaluating argument 1
    ; Variable access: len
    LDI t0, -40
    ADD t0, fp, t0
    LD t2, t0
    PUSH t2
    PUSH t1
    JAL print, ra
    LDI t0, 16
    ADD sp, sp, t0
    ; Cleaned up 2 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: console_putc
    ; Preparing function call: console_putc
    ; Evaluating argument 0
    ; Literal value: 10
    LDI t0, 10
    PUSH t0
    JAL console_putc, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: free
    ; Preparing function call: free
    ; Evaluating argument 0
    ; Variable access: message
    LDI t0, -32
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL free, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Variable assignment: countdown
    ; Arithmetic operation: SUB
    ; Variable access: countdown
    LDI t1, -24
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    SUB t0, t2, t1
    LDI t1, -24
    ADD t1, fp, t1
    ST t1, t0
    ; Variable declaration: delay
    ; Literal value: 0
    LDI t0, 0
    LDI t1, -48
    ADD t1, fp, t1
    ST t1, t0
    ; While loop
loop_116:
    ; Comparison: Variable(name=delay, type=LONG) LT Literal(value=100000, type=LONG)
    ; Variable access: delay
    LDI t0, -48
    ADD t0, fp, t0
    LD t1, t0
    ; Literal value: 100000
    LDI t0, 100000
    SUB t2, t1, t0
    ; Jump if t1 >= t0
    JPN skip_ge_118, t2
    JMP endloop_117
skip_ge_118:
    ; Variable assignment: delay
    ; Arithmetic operation: ADD
    ; Variable access: delay
    LDI t1, -48
    ADD t1, fp, t1
    LD t2, t1
    ; Literal value: 1
    LDI t1, 1
    ADD t0, t2, t1
    LDI t1, -48
    ADD t1, fp, t1
    ST t1, t0
    JMP loop_116
endloop_117:
    JMP loop_114
endloop_115:
    ; Expression statement
    ; Function call: free
    ; Preparing function call: free
    ; Evaluating argument 0
    ; Variable access: prefix
    LDI t0, -8
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL free, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Expression statement
    ; Function call: free
    ; Preparing function call: free
    ; Evaluating argument 0
    ; Variable access: empty_suffix
    LDI t0, -16
    ADD t0, fp, t0
    LD t1, t0
    PUSH t1
    JAL free, ra
    LDI t0, 8
    ADD sp, sp, t0
    ; Cleaned up 1 arguments from stack
    MOV t0, a0
    ; Function epilogue
demo_countdown_end_113:
    LDI t0, 48
    ADD sp, sp, t0
    ; Deallocated 48 bytes for frame
    POP fp
    POP ra
    JMP ra                               ; Return from function

    ; ======================================
    ; Function: main
    ; ======================================
main:
    ; Pre-allocating 0 local variables
    ; Function prologue
    PUSH ra
    PUSH fp
    MOV fp, sp
    ; Total frame size: 0 bytes
    ; Expression statement
    ; Function call: console_init
    ; Preparing function call: console_init
    JAL console_init, ra
    MOV t0, a0
    ; Expression statement
    ; Function call: demo_countdown
    ; Preparing function call: demo_countdown
    JAL demo_countdown, ra
    MOV t0, a0
    ; While loop
loop_120:
    ; Literal value: 1
    LDI t0, 1
    JZ endloop_121, t0
    JMP loop_120
endloop_121:
    ; Function epilogue
main_end_119:
    POP fp
    POP ra
    JMP ra                               ; Return from function