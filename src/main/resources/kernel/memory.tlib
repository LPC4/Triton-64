struct BlockHeader {
    var size: int           ; total size of this block (including header + payload)
    var next: BlockHeader*  ; pointer to the next free block
}

global HEAP_START: long = 0x18020000    ; start of the heap area
global HEAP_SIZE: long = 0x8000000      ; 128 MiB heap size
global HEADER_SIZE: int = strideOf(BlockHeader)
global MIN_BLOCK_SIZE: int = 16
global ALIGNMENT: int = 8

global freeListHead: BlockHeader* = 0

func align_up(size: long, alignment: long): long {
    return size + alignment - (size % alignment)
}

func init_heap() {
    if (freeListHead == 0) {
        freeListHead = HEAP_START
        freeListHead.size = HEAP_SIZE
        freeListHead.next = 0
    }
}

func unlink_block(block: BlockHeader*, prev: BlockHeader*) {
    if (prev == 0) {
        freeListHead = block.next
    } else {
        prev.next = block.next
    }
}

func split_block(block: BlockHeader*, needed_size: long) {
    var remaining: long = block.size - needed_size

    if (remaining >= MIN_BLOCK_SIZE) {
        var new_block: BlockHeader* = BlockHeader*(block + needed_size)
        new_block.size = remaining
        new_block.next = freeListHead
        freeListHead = new_block

        block.size = needed_size
        block.next = 0
    } else {
        block.next = 0
    }
}

func malloc(size_req: long): long {
    if (size_req == 0) {
        return 0
    }

    init_heap()

    var total_needed: long = align_up(size_req + HEADER_SIZE, ALIGNMENT)

    var current: BlockHeader* = freeListHead
    var prev: BlockHeader* = 0

    while (current != 0) {
        if (current.size >= total_needed) {
            unlink_block(current, prev)
            split_block(current, total_needed)
            return long(current) + HEADER_SIZE
        }

        prev = current
        current = current.next
    }

    return 0
}

func free(ptr: long) {
    if (ptr == 0) { return }

    var block: BlockHeader* = BlockHeader*(ptr - HEADER_SIZE)
    block.next = freeListHead
    freeListHead = block

    coalesce_free_blocks()
}

func realloc(ptr: long, new_size: long): long {
    if (ptr == 0) {
        return malloc(new_size)
    }

    if (new_size == 0) {
        free(ptr)
        return 0
    }

    var block: BlockHeader* = BlockHeader*(ptr - HEADER_SIZE)
    var current_size: long = block.size - HEADER_SIZE
    var aligned_new_size: long = align_up(new_size, ALIGNMENT)

    if (aligned_new_size <= current_size) {
        return ptr
    }

    var new_ptr: long = malloc(new_size)
    if (new_ptr == 0) {
        return 0
    }

    var copy_size: long = current_size
    if (aligned_new_size < copy_size) {
        copy_size = aligned_new_size
    }

    var i: long = 0
    while (i < copy_size) {
        byte@(new_ptr + i) = byte@(ptr + i)
        i = i + 1
    }

    free(ptr)
    return new_ptr
}

func calloc(count: long, size: long): long {
    var total_size: long = count * size
    var ptr: long = malloc(total_size)

    if (ptr == 0) {
        return 0
    }

    var i: long = 0
    while (i < total_size) {
        byte@(ptr + i) = 0
        i = i + 1
    }

    return ptr
}

func coalesce_free_blocks() {
    if (freeListHead == 0) { return }

    var current: BlockHeader* = freeListHead

    while (current != 0) {
        var next: BlockHeader* = current.next
        if (next != 0 && long(next) == long(current) + current.size) {
            current.size = current.size + next.size
            current.next = next.next
        } else {
            current = next
        }
    }
}
