struct BlockHeader {
    var size: int
    var next: BlockHeader*
}

global __HEAP_START: long = 0x18020000
global __HEAP_SIZE: long = 0x8000000
global __HEADER_SIZE: int = strideOf(BlockHeader)
global __MIN_BLOCK_SIZE: int = 16
global __ALIGNMENT: int = 8
global __freeListHead: BlockHeader* = 0

func __align_up(size: long, alignment: long): long {
    return size + alignment - (size % alignment)
}

func __init_heap() {
    if (__freeListHead == 0) {
        __freeListHead = __HEAP_START
        __freeListHead.size = __HEAP_SIZE
        __freeListHead.next = 0
    }
}

func __unlink_block(block: BlockHeader*, prev: BlockHeader*) {
    if (prev == 0) {
        __freeListHead = block.next
    } else {
        prev.next = block.next
    }
}

func __split_block(block: BlockHeader*, needed_size: long) {
    var remaining: long = block.size - needed_size

    if (remaining >= __MIN_BLOCK_SIZE) {
        var new_block: BlockHeader* = BlockHeader*(block + needed_size)
        new_block.size = remaining
        new_block.next = __freeListHead
        __freeListHead = new_block

        block.size = needed_size
        block.next = 0
    } else {
        block.next = 0
    }
}

func __coalesce_free_blocks() {
    if (__freeListHead == 0) { return }

    var current: BlockHeader* = __freeListHead

    while (current != 0) {
        var next: BlockHeader* = current.next
        if (next != 0 && long(next) == long(current) + current.size) {
            current.size = current.size + next.size
            current.next = next.next
        } else {
            current = next
        }
    }
}

func malloc(size_req: long): long {
    if (size_req == 0) {
        return 0
    }

    __init_heap()

    var total_needed: long = __align_up(size_req + __HEADER_SIZE, __ALIGNMENT)

    var current: BlockHeader* = __freeListHead
    var prev: BlockHeader* = 0

    while (current != 0) {
        if (current.size >= total_needed) {
            __unlink_block(current, prev)
            __split_block(current, total_needed)
            return long(current) + __HEADER_SIZE
        }

        prev = current
        current = current.next
    }

    return 0
}

func free(ptr: long) {
    if (ptr == 0) { return }

    var block: BlockHeader* = BlockHeader*(ptr - __HEADER_SIZE)
    block.next = __freeListHead
    __freeListHead = block

    __coalesce_free_blocks()
}

func realloc(ptr: long, new_size: long): long {
    if (ptr == 0) {
        return malloc(new_size)
    }

    if (new_size == 0) {
        free(ptr)
        return 0
    }

    var block: BlockHeader* = BlockHeader*(ptr - __HEADER_SIZE)
    var current_size: long = block.size - __HEADER_SIZE
    var aligned_new_size: long = __align_up(new_size, __ALIGNMENT)

    if (aligned_new_size <= current_size) {
        return ptr
    }

    var new_ptr: long = malloc(new_size)
    if (new_ptr == 0) {
        return 0
    }

    var copy_size: long = current_size
    if (aligned_new_size < copy_size) {
        copy_size = aligned_new_size
    }

    var i: long = 0
    while (i < copy_size) {
        byte@(new_ptr + i) = byte@(ptr + i)
        i = i + 1
    }

    free(ptr)
    return new_ptr
}

func calloc(count: long, size: long): long {
    var total_size: long = count * size
    var ptr: long = malloc(total_size)

    if (ptr == 0) {
        return 0
    }

    var i: long = 0
    while (i < total_size) {
        byte@(ptr + i) = 0
        i = i + 1
    }

    return ptr
}